---
title: "Chapter 3 — Diffusion Modeling with Pupil-Linked Arousal (Response-Signal Design)"
author: "Mohammad Dastgheib"
bibliography: references.bib
csl: apa-7th-edition.csl
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    embed-resources: true
  pdf:
    toc: true
    toc-depth: 3
    number-sections: true
    documentclass: article
    geometry:
      - margin=1in
    fontsize: 11pt
    linestretch: 1.5
    fig-pos: "H"
  docx:
    toc: true
    number-sections: true

execute:
  echo: false
  warning: false
  message: false
---

```{r setup}
library(dplyr)
library(readr)
library(tidyr)
library(gt)
library(glue)
library(stringr)
library(knitr)
library(ggplot2)
library(rlang)
op <- options(width = 120)
on.exit(options(op), add = TRUE)

`%||%` <- function(x, y) if (is.null(x) || length(x) == 0) y else x

# Set working directory to project root (Quarto runs from reports/ directory)
if (basename(getwd()) == "reports") {
  setwd("..")
}
# Ensure we're in project root for file paths
proj_root <- getwd()
p <- file.path(proj_root, "output/publish")
# Ensure p is a single character string
if (length(p) > 1) p <- p[1]

# Helper: figure path resolution
# Returns PNG for HTML output, PDF for DOCX output
fig_path <- function(fig_name) {
  # Get base name without extension
  base_name <- tools::file_path_sans_ext(fig_name)
  
  # Detect output format - try multiple methods
  output_format <- NULL
  
  # Method 1: Check knitr's pandoc output format (most reliable)
  pandoc_to <- knitr::opts_knit$get("rmarkdown.pandoc.to")
  if (!is.null(pandoc_to)) {
    output_format <- pandoc_to
  }
  
  # Method 2: Check if we're in a DOCX rendering context
  # Quarto sets this in the knitr options
  if (is.null(output_format)) {
    # Check for DOCX-specific indicators
    docx_indicators <- c(
      knitr::opts_knit$get("quarto.document.format") == "docx",
      grepl("docx", knitr::opts_knit$get("out.format") %||% "", ignore.case = TRUE)
    )
    if (any(docx_indicators, na.rm = TRUE)) {
      output_format <- "docx"
    }
  }
  
  png_name <- paste0(base_name, ".png")
  pdf_name <- paste0(base_name, ".pdf")
  
  # Find the actual file location
  png_abs <- NULL
  pdf_abs <- NULL
  
  candidates_png <- c(
    file.path(proj_root, "output/figures", png_name),
    file.path("output/figures", png_name),
    file.path("../output/figures", png_name)
  )
  
  candidates_pdf <- c(
    file.path(proj_root, "output/figures", pdf_name),
    file.path("output/figures", pdf_name),
    file.path("../output/figures", pdf_name)
  )
  
  for (path in candidates_png) {
    if (file.exists(path)) {
      png_abs <- normalizePath(path)
      break
    }
  }
  
  for (path in candidates_pdf) {
    if (file.exists(path)) {
      pdf_abs <- normalizePath(path)
      break
    }
  }
  
  # Choose format based on output type
  # DOCX: prefer PDF (vector graphics work better in Word)
  # HTML: prefer PNG (better browser compatibility)
  if (!is.null(output_format) && grepl("docx|word", output_format, ignore.case = TRUE)) {
    if (!is.null(pdf_abs)) {
      # For DOCX, return relative path (Word handles it)
      return(file.path("../output/figures", pdf_name))
    } else if (!is.null(png_abs)) {
      return(file.path("../output/figures", png_name))
    }
  } else {
    # HTML: use relative path from reports/ directory
    # Quarto will handle copying if needed
    if (!is.null(png_abs)) {
      return(file.path("../output/figures", png_name))
    } else if (!is.null(pdf_abs)) {
      return(file.path("../output/figures", pdf_name))
    }
  }
  
  # Fallback
  warning("Figure not found: ", fig_name)
  return(file.path("../output/figures", if (!is.null(png_abs)) png_name else pdf_name))
}

# Helper: safe read
sread <- function(path) {
  # Ensure path is a single character string
  if (length(path) > 1) {
    path <- path[1]  # Take first if multiple
  }
  if (length(path) == 1 && is.character(path) && file.exists(path)) {
    tryCatch(read_csv(path, show_col_types = FALSE), error = function(e) NULL)
  } else {
    NULL
  }
}

# --- Load all data files ---
# QA files
qa_exclusions <- sread(file.path(p, "qa_trial_exclusions.csv"))
qa_subj       <- sread(file.path(p, "qa_subject_inclusion.csv"))
qa_decision   <- sread(file.path(p, "qa_decision_coding_audit.csv"))
qa_mvc        <- sread(file.path(p, "qa_mvc_compliance.csv"))

# Manipulation checks
acc_glmm <- sread(file.path(p, "checks_accuracy_glmm.csv"))
rt_lmm   <- sread(file.path(p, "checks_rt_lmm.csv"))

# LOO comparison
loo_primary <- sread(file.path(p, "loo_summary_clean.csv")) %||% 
               sread(file.path(p, "table1_loo_primary.csv")) %||% 
               sread("loo_difficulty_all.csv")

# Convergence and publish gate
conv_primary <- sread(file.path(p, "table2_convergence_primary.csv"))
publish_gate <- sread(file.path(p, "publish_gate_primary_censored.csv"))

# PPC tables
ppc_subj_cens   <- sread(file.path(p, "table3_ppc_primary_subjectwise_censored.csv"))
ppc_uncond_cens <- sread(file.path(p, "table3_ppc_primary_unconditional_censored.csv"))
ppc_cond_cens   <- sread(file.path(p, "table3_ppc_primary_conditional_censored.csv"))
ppc_gate        <- sread(file.path(p, "ppc_gate_summary.csv"))
ppc_cells       <- sread(file.path(p, "ppc_cells_detail.csv"))

# Fixed effects and contrasts
fx_table        <- sread(file.path(p, "table_fixed_effects.csv"))
contrasts_table <- sread(file.path(p, "table_effect_contrasts.csv"))

# Heatmap tables
heatmap_wide <- sread(file.path(p, "ppc_heatmap_wide.csv"))
heatmap_long <- sread(file.path(p, "ppc_heatmap_long.csv"))

# Bias model results (response-side coding)
bias_levels_std <- sread(file.path(p, "bias_standard_only_levels.csv"))
bias_contr_std <- sread(file.path(p, "bias_standard_only_contrasts.csv"))
bias_contr_joint <- sread(file.path(p, "bias_joint_contrast.csv"))
ppc_joint_minimal <- sread(file.path(p, "ppc_joint_minimal.csv"))

# Sensitivity analyses
sensitivity_summary <- sread("output/checks/sensitivity_summary.csv") %||%
                      sread("output/sensitivity/sensitivity_summary.csv")

# Load behavioral data for descriptives (if available)
# Try multiple possible locations, prioritizing the Nov2025 directory
behavioral_data_paths <- c(
  "/Users/mohdasti/Documents/LC-BAP/BAP/Nov2025/bap_beh_trialdata_v2.csv",
  file.path(proj_root, "data/analysis_ready/BAP_analysis_ready_BEHAVIORAL.csv"),
  file.path(proj_root, "data/analysis_ready/behavioral_data.csv"),
  file.path(proj_root, "data/raw/bap_beh_trialdata_v2.csv"),
  file.path(proj_root, "../bap_beh_trialdata_v2.csv"),
  "data/analysis_ready/BAP_analysis_ready_BEHAVIORAL.csv",
  "data/analysis_ready/behavioral_data.csv"
)

behavioral_data <- NULL
for (path in behavioral_data_paths) {
  if (file.exists(path)) {
    tryCatch({
      behavioral_data <- read_csv(path, show_col_types = FALSE)
      # Standardize column names
      if ("subject_id" %in% names(behavioral_data)) {
        behavioral_data <- behavioral_data %>% mutate(sub = as.character(subject_id))
      }
      if ("task_modality" %in% names(behavioral_data)) {
        behavioral_data <- behavioral_data %>%
          mutate(task = case_when(
            task_modality == "aud" ~ "ADT",
            task_modality == "vis" ~ "VDT",
            TRUE ~ as.character(task_modality)
          ))
      }
      if ("same_diff_resp_secs" %in% names(behavioral_data)) {
        behavioral_data <- behavioral_data %>% mutate(rt = same_diff_resp_secs)
      } else if ("resp1RT" %in% names(behavioral_data)) {
        behavioral_data <- behavioral_data %>% mutate(rt = resp1RT)
      }
      if ("resp_is_correct" %in% names(behavioral_data)) {
        behavioral_data <- behavioral_data %>% mutate(iscorr = as.integer(resp_is_correct))
      }
      # Map effort_condition from grip_level
      if ("grip_level" %in% names(behavioral_data)) {
        behavioral_data <- behavioral_data %>%
          mutate(effort_condition = case_when(
            grip_level == "low" ~ "Low_5_MVC",
            grip_level == "high" ~ "High_40_MVC",
            TRUE ~ as.character(grip_level)
          ))
      }
      # Map difficulty_level from stim_offset and stim_is_diff
      # Standard: stim_is_diff = FALSE or stim_offset = 0
      # Hard: Small offsets that are hard to distinguish from Standard
      #   ADT: 8 Hz and 16 Hz
      #   VDT: 0.06 and 0.12 contrast
      # Easy: Large offsets that are easy to distinguish from Standard
      #   ADT: 32 Hz and 64 Hz
      #   VDT: 0.24 and 0.48 contrast
      if ("stim_offset" %in% names(behavioral_data) && "stim_is_diff" %in% names(behavioral_data)) {
        behavioral_data <- behavioral_data %>%
          mutate(difficulty_level = case_when(
            stim_is_diff == FALSE | is.na(stim_offset) | stim_offset == 0 ~ "Standard",
            # ADT: Easy = 32 or 64 Hz; Hard = 8 or 16 Hz
            task == "ADT" & stim_offset %in% c(32, 64) ~ "Easy",
            task == "ADT" & stim_offset %in% c(8, 16) ~ "Hard",
            # VDT: Easy = 0.24 or 0.48 contrast; Hard = 0.06 or 0.12 contrast
            task == "VDT" & stim_offset %in% c(0.24, 0.48) ~ "Easy",
            task == "VDT" & stim_offset %in% c(0.06, 0.12) ~ "Hard",
            TRUE ~ "Standard"
          ))
      } else if ("stim_level_index" %in% names(behavioral_data) && "stim_is_diff" %in% names(behavioral_data)) {
        # Fallback: use stim_level_index if stim_offset not available
        # NOTE: Please confirm this mapping - typically: 0=Standard, 4=Easy, 2=Hard
        behavioral_data <- behavioral_data %>%
          mutate(difficulty_level = case_when(
            stim_is_diff == FALSE | stim_level_index == 0 ~ "Standard",
            stim_level_index == 4 ~ "Easy",
            stim_level_index %in% c(1, 2) ~ "Hard",
            stim_level_index == 3 ~ "Easy",
            TRUE ~ "Standard"
          ))
      }
      break
    }, error = function(e) {
      cat("Error loading", path, ":", e$message, "\n")
      NULL
    })
  }
}

# Derive simple pass/fail summaries
pf_subj <- if (!is.null(ppc_subj_cens)) {
  if ("any_flag" %in% names(ppc_subj_cens)) {
    ppc_subj_cens %>% 
      summarise(n_cells = n(), n_flagged = sum(any_flag, na.rm=TRUE), 
                pct_flagged = round(100*mean(any_flag, na.rm=TRUE),1))
  } else {
    ppc_subj_cens %>% 
      mutate(any_flag = (qp_rmse_midbody > 0.09) | (ks_mean > 0.15)) %>%
      summarise(n_cells = n(), n_flagged = sum(any_flag, na.rm=TRUE), 
                pct_flagged = round(100*mean(any_flag, na.rm=TRUE),1))
  }
} else tibble(n_cells=NA, n_flagged=NA, pct_flagged=NA)

pf_uncond <- if (!is.null(ppc_uncond_cens)) {
  if ("any_flag" %in% names(ppc_uncond_cens)) {
    ppc_uncond_cens %>% 
      summarise(n_cells = n(), n_flagged = sum(any_flag, na.rm=TRUE), 
                pct_flagged = round(100*mean(any_flag, na.rm=TRUE),1))
  } else {
    ppc_uncond_cens %>% 
      mutate(any_flag = (qp_rmse_midbody > 0.09) | (ks_mean > 0.15)) %>%
      summarise(n_cells = n(), n_flagged = sum(any_flag, na.rm=TRUE), 
                pct_flagged = round(100*mean(any_flag, na.rm=TRUE),1))
  }
} else tibble(n_cells=NA, n_flagged=NA, pct_flagged=NA)
```


# Abstract {.unnumbered}

This chapter presents a hierarchical Wiener diffusion decision model (DDM) for a response-signal change-detection task in older adults. The primary model maps task difficulty to drift rate (v) and boundary separation (a), with starting-point bias (z) varying by task and effort but constant across difficulty levels (reflecting the randomized trial design), and small condition effects on non-decision time (t₀). We report comprehensive quality assurance checks, manipulation checks independent of the DDM, model comparison via LOO cross-validation, and extensive posterior predictive checks with emphasis on subject-wise mid-body RT quantiles.

# Introduction

## Age-Related Slowing and Strategic Adaptation in Decision-Making

A hallmark of cognitive aging is a pervasive slowing of response times across virtually all task domains. Older adults consistently take longer to respond in speeded decision tasks than younger adults, a phenomenon historically interpreted as *generalized slowing* [@birren1965age; @salthouse1985speed]. Classic analyses using Brinley plots [@brinley1965cognitive] supported the idea of a global factor that uniformly slows processing with age [@cerella1985; @salthouse1996]. In fact, increased age is associated with a decrease in the speed of many mental operations, as posited by the processing-speed theory of cognitive aging [@salthouse1996]. According to this view, slower processing leaves less time for higher-order operations, effectively creating a bottleneck in available cognitive resources. However, simply viewing aging as a uniform "slower clock speed" obscures important nuances. Older adults often maintain accuracy rates comparable to younger adults by adjusting their decision-making strategy: they tend to respond more cautiously, emphasizing accuracy over speed. In other words, rather than being a passive consequence of a slower brain, longer response times in older people can reflect an active, strategic adaptation aimed at preserving accuracy in the face of cognitive and neural challenges. Empirical evidence for this adaptive strategy comes from speed--accuracy tradeoff studies showing that, when given the option, seniors favor slower, more accurate responding, whereas younger adults are willing to respond faster at the cost of more errors [@ratcliff2004aging; @starns2010; @rabbitt1979old]. This age-related shift toward a "slow but sure" decision mode is often interpreted as an adaptive mechanism: older adults may consciously or unconsciously slow down to avoid mistakes, compensating for declines in sensory or cognitive processing by "buying" extra decision time [@mata2007aging; @ratcliff2006aging].

Notably, this cautious response style means that aging effects on decision performance are not uniform across all components of processing. Contemporary cognitive aging models distinguish between generalized slowing and component-specific changes in decision dynamics. For example, older adults experience sensory and perceptual degradations, often conceptualized as a reduction in neural signal-to-noise ratio [@li2001aging; @lindenberger1994sensory], as well as distinct motor slowing [@seidler2010motor], which each can prolong portions of the response time independent of decision strategy. Simultaneously, older adults exhibit changes in decision criteria, such as setting a higher threshold for required evidence before responding [@ratcliff2001aging; @ratcliff2004aging; @ratcliff2007application; @ratcliff2008diffusion]. This raises an important question: does aging slow core cognitive processing speed, or do older adults simply recalibrate their speed--accuracy tradeoff by becoming more cautious? The answer appears to be a combination of both, depending on task demands. In relatively simple perceptual decision tasks—such as brightness discrimination or letter identification—healthy older adults often achieve accuracy similar to young adults by adopting conservative decision thresholds and taking more time, rather than by processing information more efficiently [@ratcliff2001aging; @ratcliff2003diffusion]. Critically, drift rates (the quality of evidence accumulation) are preserved in these simple perceptual tasks, indicating that fundamental cognitive processing capacity remains intact when task demands are low. In contrast, under more challenging conditions—specifically episodic memory tasks requiring recollection of contextual details [@spaniol2006] or complex visual searches requiring serial attention allocation [@madden1991]—older adults exhibit genuine declines in drift rates. This indicates real reductions in the quality of decision-driving information. Thus, while slower responses in simple tasks reflect a strategic emphasis on accuracy (criterion shift) and slower peripheral processes, complex tasks reveal a different pattern. When cognitive demands exceed the older brain's capacity, seniors often cannot maintain the same quality of evidence accumulation as the young, leading to performance decrements when they attempt to respond quickly. These findings underscore that aging impacts decision-making through multiple pathways: a general tendency toward slower, more cautious responding, coupled with task-specific deficits in processing efficiency when cognitive demands are high.

## Insights from Drift-Diffusion Modeling of Aging

To disentangle these component processes of decision-making, researchers increasingly turn to computational modeling approaches. One powerful framework is the Drift Diffusion Model (DDM), which provides a quantitative decomposition of choice reaction time data into psychologically interpretable parameters [@ratcliff1978theory; @ratcliff2008diffusion; @voss2004interpreting]. In a forced-choice decision task, the DDM conceptualizes the process as a gradual, noisy accumulation of evidence toward one of two decision boundaries (representing the response options). The key model parameters include:

-   **Drift rate ($v$)** – the average speed of evidence accumulation toward the correct decision. This reflects the quality or efficiency of information processing; a higher drift rate means the decision maker can extract and use task-relevant information more quickly.
-   **Decision boundary ($a$)** – the amount of evidence required to commit to a choice, often interpreted as response caution or threshold. A larger boundary separation indicates a more cautious strategy (waiting for more evidence before deciding), whereas a smaller boundary implies a more impulsive or speed-emphasizing strategy.
-   **Starting point ($z$)** – the initial bias or predisposition toward one option or the other before evidence is accumulated. If the starting point is centered (typically 0.5 in relative units), there is no pre-existing bias; deviations from center indicate an a priori bias to favor a particular response (e.g., a bias to say "yes" vs "no" in a detection task).
-   **Non-decision time ($t_0$)** – the duration of processes outside of the evidence accumulation itself, such as perceptual encoding of the stimulus and the motor execution of the response [@voss2004interpreting]. Non-decision time accounts for aspects of the reaction time that are not decision-related.

```{r}
#| label: fig-ddm-process
#| fig-cap: "Drift Diffusion Model: Evidence Accumulation Process. The DDM models decision-making as a noisy evidence accumulation process. Evidence accumulates from a starting point (z, starting-point bias) toward one of two decision boundaries: the upper boundary corresponds to \"different\" responses, and the lower boundary to \"same\" responses. The rate of evidence accumulation is determined by the drift rate (v), which reflects the quality of the stimulus evidence. The distance between boundaries is the boundary separation (a), which reflects response caution. The total reaction time (RT) is the sum of non-decision time (t₀, reflecting perceptual encoding and motor execution) and the decision time (time to reach a boundary). In this example, the starting point is biased toward the upper boundary (z > 0.5), and positive drift leads to a \"different\" response."
#| fig-width: 80
#| fig-align: center
knitr::include_graphics(fig_path("fig_ddm_process.pdf"))
```

Formally, the evidence accumulation process follows the stochastic differential equation [@ratcliff1978theory; @ratcliff2008diffusion]:

$$dX(t) = v \, dt + dW(t)$$ {#eq-sde}

where $X(t)$ is the accumulated evidence at time $t$, $v$ is the drift rate (evidence strength), and $dW(t)$ is a Wiener noise process with unit variance. The process starts at $X(0) = z \cdot a$, where $z \in [0,1]$ is the starting-point bias (expressed as a proportion of boundary separation) and $a > 0$ is the boundary separation [@ratcliff2008diffusion]. The decision process terminates when $X(t)$ reaches either the upper boundary ($X(t) = a$) or the lower boundary ($X(t) = 0$). The total reaction time (RT) is the sum of the decision time and the non-decision time ($t_0$):

$$\text{RT} = t_{\text{decision}} + t_0$$ {#eq-rt}

By fitting the DDM to participants' accuracy and response time distributions, one can infer how these latent parameters differ between groups (e.g. young vs. old) or conditions. This model-based approach has proved especially illuminating in aging research. Rather than relying on overall slowing measures alone, the DDM allows researchers to pinpoint which aspects of processing slow down or change with age and which remain intact.

The DDM mathematically formalizes the behavioral patterns described above. The model confirms that older adults' slower responses are largely due to shifts in caution and peripheral processing, rather than uniformly impaired evidence accumulation. Specifically, older adults consistently exhibit significantly higher decision thresholds ($a$) than younger adults across a variety of tasks [@ratcliff2004aging; @ratcliff2008diffusion], quantitatively capturing the strategic slowing: by widening the distance between boundaries, older adults counteract internal noise and maintain high accuracy. Additionally, the model isolates the contribution of peripheral slowing; older adults typically show increased non-decision times ($t_0$), often 80–100 ms longer than young adults [@ratcliff2004aging], reflecting age-related delays in motor execution and sensory encoding. Crucially, the DDM reveals that drift rate ($v$)—the core measure of cognitive processing efficiency—is often remarkably preserved in aging for simple perceptual tasks [@ratcliff2001aging; @ratcliff2003diffusion; @ratcliff2004aging].

However, as noted previously, this preservation is not universal: in tasks taxing memory retrieval [@spaniol2006] or complex visual search [@madden1991], modeling confirms a decline in drift rates, indicating that for complex cognitive operations, the older brain does accumulate evidence more slowly. Furthermore, while older adults can adjust their boundaries, they often exhibit a rigidity in this setting; Starns and Ratcliff [-@starns2010] demonstrated that older adults fail to lower their boundaries ($a$) optimally under speed pressure, prioritizing accuracy even when the task incentivizes speed. Regarding bias ($z$), healthy aging is generally not associated with systematic shifts in starting point for simple tasks, though specific biases can emerge in memory paradigms (e.g., a conservative bias against "new" items to avoid false alarms) [@spaniol2006; @ratcliff2004aging]. Overall, the application of drift-diffusion modeling provides a nuanced portrait of aging: it mathematically separates the strategic adaptations (increased $a$) and peripheral slowing (increased $t_0$) from the fundamental cognitive capacity (drift rate $v$), which remains intact in simple contexts but declines under high cognitive load. 

Having established the baseline DDM profile of older adults, we turn to an important modulating factor: arousal and effort. In this chapter, we leverage the diffusion model to investigate how fluctuations in arousal (induced via physical effort) can alter these latent decision processes in older adults.

## Arousal, Effort, and Decision Performance in Older Adults

Beyond baseline aging effects, cognitive performance is strongly influenced by the organism's arousal state—the level of alertness or activation of physiological and neural systems. Classic theory, dating back to the Yerkes–Dodson law [@yerkes1908], holds that the relationship between arousal and performance follows an inverted-U function: increasing arousal enhances performance up to an optimal point, after which further arousal (especially if reaching stress or anxiety levels) impairs performance. In the context of aging, this dynamic takes on special significance. **Adaptive Gain Theory (AGT)** [@astonjones2005] provides a neural mechanism for this relationship, linking phasic and tonic Locus Coeruleus activity to optimal task performance. When this framework is extended to aging, researchers posit that the arousal--performance curve is altered, often manifesting as a leftward shift or compression of the inverted-U function [@mather2016; @mikneviciute2022]. This implies that older adults may reach their "optimal" arousal peak at lower levels of objective demand than younger adults. Consequently, levels of effort or stress that might be engaging or beneficial for a younger adult (placing them at the peak of the curve) can push an older adult onto the "descending limb," leading to supra-optimal arousal and performance decrements [@huang2024; @mather2016].

Older adults typically have a reduced physiological capacity to sustain high arousal yet often need to exert greater mental effort to perform a given task at the same level as a younger person. Recent studies support the idea that effortful engagement is more taxing for older adults in measurable ways. For example, Hess and Ennis [@hess2012] demonstrated that when older adults performed continuous arithmetic tasks (e.g., subtraction), they exhibited significantly larger increases in systolic blood pressure (SBP)—a physiological index of effortful arousal—than young adults, and this elevated physiological cost predicted greater fatigue on subsequent tasks. Furthermore, research directly relevant to the current paradigm has shown that concurrent physical effort can be detrimental to cognition in aging. Azer et al. [@azer2023] found that while maintaining a concurrent moderate isometric handgrip (30% MVC), older adults showed significantly reduced accuracy in a visual working memory task with distractors, whereas younger adults remained unaffected. This supports the **limited-capacity framework**, suggesting that shared processing resources [@wickens2008] are more easily depleted in older adults, or that the combined demand drives arousal into a dysregulated state [@verhaeghen2003].
What are the expected effects of arousal fluctuations on the decision-making mechanisms of older adults? By applying the drift-diffusion model (DDM), we can make specific hypotheses about how effort-induced arousal will modulate latent decision parameters. The present study manipulates arousal via physical effort (5% vs. 40% MVC), providing a controlled way to "push" older participants along the arousal curve. Behavioral theories such as Resource Competition and Limited Capacity predict that excessive effort will siphon processing resources away from the decision process, degrading evidence quality, whereas Adaptive Gain Theory predicts that older adults will more quickly slide down the descending limb of the inverted-U curve when demands are high. These frameworks collectively motivate the computational predictions outlined after we review the relevant physiological mechanisms.

## Arousal Dynamics and the Locus Coeruleus-Norepinephrine System

Beyond the structural decision parameters captured by the DDM, cognitive performance is dynamically modulated by the brain's arousal state. A central regulator of this arousal is the Locus Coeruleus-Norepinephrine (LC-NE) system, a small brainstem nucleus that serves as the primary source of norepinephrine to the forebrain [@astonjones2005]. The LC-NE system modulates the "neural gain" of cortical circuits—essentially the signal-to-noise ratio of information processing. According to Adaptive Gain Theory (AGT), optimal performance relies on a balance between two modes of LC activity: a moderate tonic (baseline) firing rate that promotes focused attention, and robust phasic (event-related) bursts that facilitate rapid behavioral responses to task-relevant stimuli [@astonjones2005; @gilzenrat2010].

In the context of aging, this system undergoes significant changes. While structural degradation of the LC is common in older adults [@mather2016], functional compensatory mechanisms often emerge. Older adults may exhibit chronically elevated tonic arousal or hyper-responsivity to challenge, potentially as a strategy to offset neural inefficiency [@lee2018; @mather2016neural]. However, this compensation has limits; Adaptive Gain Theory suggests that the relationship between arousal and performance follows an inverted-U function [@yerkes1908], which in older adults may be shifted or compressed [@mather2016]. Consequently, levels of physical or cognitive effort that would optimize arousal in younger adults might push older adults into a supra-optimal state (the "descending limb" of the curve), where excessive norepinephrine release leads to distractibility, indiscriminate processing, and performance decrements [@astonjones2005; @eldar2013].

**Pupillometry** provides a powerful, non-invasive window into these LC-NE dynamics. Because pupil diameter tracks LC firing activity with high temporal precision [@joshi2016; @murphy2014], it serves as a proxy for both tonic and phasic arousal states.

-   **Baseline Pupil Diameter:** Reflects tonic LC activity and general alertness levels [@gilzenrat2010].

-   **Task-Evoked Pupil Response (TEPR):** Reflects phasic LC activation and the mobilization of mental effort during task execution [@beatty1982]. Specifically, the amplitude and latency of the TEPR—often quantified as the Area Under the Curve (AUC)—have been linked to the subjective difficulty of a task and the cognitive resources recruited to perform it [@kahneman1966; @vangerven2004].

Crucially, recent computational work has begun to bridge the gap between these physiological arousal signals and the latent cognitive processes of decision-making. In a seminal study, Cavanagh et al. [-@cavanagh2014] demonstrated that eye tracking and pupillometry serve as indicators of dissociable latent decision processes. By applying hierarchical Bayesian DDM to a probabilistic learning task, they found that while gaze dwell time predicted the rate of evidence accumulation (drift rate), **pupil dilation specifically predicted an increase in the decision threshold ($a$)** during high-conflict choices. This finding fundamentally reframed the role of phasic arousal in decision-making: rather than merely "energizing" the system generally, the pupil-linked arousal response can act as a specific signal for cognitive control, prompting a "hold your horses" mechanism [@frank2006] that raises the decision boundary to prevent impulsive errors. This link between pupil dilation and threshold adjustment ($a$) has since been corroborated by others, suggesting it may be a general marker of decision uncertainty and conflict monitoring [@urai2017; @vanderwel2018].

This connection is vital for the present study. By integrating pupillometry with DDM, we can move beyond simple behavioral outcomes to ask mechanistic questions about how physical effort impacts the aging brain. Does the physical arousal from a high-effort handgrip act as a beneficial boost that sharpens neural gain (increasing drift rate, $v$), as Adaptive Gain Theory might predict for moderate arousal? Or, does it trigger a conflict signal that prompts older adults to become more conservative (increasing threshold, $a$), as suggested by the work of Cavanagh et al. [-@cavanagh2014]? Alternatively, if the effort pushes older adults into a supra-optimal state, does the pupil signal reflect internal noise that degrades evidence quality (decreasing $v$)? This combined pupil-DDM approach allows us to directly test these competing hypotheses by linking observable physiological states to the latent computational components of the decision process.

### Hypotheses and Predictions

Grounded in the behavioral and physiological frameworks above, we test four preregistered predictions:

1. **Drift rate ($v$)** will decrease under high effort (40% MVC) relative to low effort, reflecting degraded evidence accumulation from resource competition or supra-optimal arousal.
2. **Boundary separation ($a$)** will increase under high effort, reflecting the conflict-control signal suggested by phasic pupil-linked arousal and older adults’ strategic caution.
3. **Non-decision time ($t_0$)** may increase modestly under high effort, reflecting cognitive-motor interference during concurrent grip maintenance.
4. **Starting bias ($z$)** may move toward 0.5 if high-effort trials evoke strong phasic LC-NE responses that “reset” pre-existing response tendencies [@deGee2020pupil], with the magnitude of any shift moderated by LC integrity [@huang2024].

## Conclusion and Overview of the Present Study

In this chapter, we investigate how effort-induced arousal modulates decision-making in older adults at a computational level. By applying hierarchical Bayesian drift-diffusion modeling (HDDM) to behavioral data from older participants under low-effort vs. high-effort conditions, we test whether heightened arousal degrades evidence accumulation, triggers compensatory increases in boundary separation, alters bias, or slows non-decision processes. By decomposing older adults’ performance with the DDM, we can pinpoint the locus of the arousal effect: is it degrading the evidence itself, shifting the strategic criterion, resetting biases, or altering peripheral processing speeds? This approach allows us to move beyond simple outcome measures (mean reaction time or accuracy) to visualize the mechanism of how a physiologically loaded aging brain arrives at a choice. The broader significance of this work lies in understanding whether the characteristic cautiousness and processing inefficiencies of older decision-makers are fixed traits or dynamic features modulated by physiological state. If arousal can “tune” decision parameters in predictable ways, it suggests that decision performance in aging is not static but state-dependent. If excessive effort proves detrimental as hypothesized, it highlights the critical importance of effort regulation and stress management for older individuals in demanding environments. Ultimately, by mathematically decomposing these effects, we seek to clarify whether boosting arousal in older adults helps “overclock” their decision processes or instead exacerbates underlying capacity limits. This knowledge contributes to a more comprehensive theory of cognitive aging—one that accounts for both the baseline architectural changes of the brain and the dynamic, moment-to-moment influence of internal physiological states.


# Methods

## DDM Implementation

### Parameter Transformations (Link Functions)

To ensure parameter constraints, we apply link functions [@ratcliff2002estimating; @burkner2017brms]. The model was implemented using the `brms` package with `family = wiener(link_bs="log", link_ndt="log", link_bias="logit")`:

-   **Drift rate**: $v = \beta_v$ (identity link)
-   **Boundary separation**: $a = \exp(\beta_{\text{bs}})$ (log link, ensures $a > 0$)
-   **Non-decision time**: $t_0 = \exp(\beta_{\text{ndt}})$ (log link, ensures $t_0 > 0$)
-   **Starting-point bias**: $z = \text{logit}^{-1}(\beta_{\text{bias}}) = \frac{\exp(\beta_{\text{bias}})}{1 + \exp(\beta_{\text{bias}})}$ (logit link, ensures $z \in [0,1]$)

### Hierarchical Structure

For subject $i$ and trial $j$, the model parameters are [@burkner2017brms; @ratcliff2008diffusion]:

$$v_{ij} = \beta_{v,0} + \sum_k \beta_{v,k} X_{k,ij} + u_{v,i}$$ {#eq-drift-hierarchical}

$$a_{ij} = \exp\left(\beta_{\text{bs},0} + \sum_k \beta_{\text{bs},k} X_{k,ij} + u_{\text{bs},i}\right)$$ {#eq-boundary-hierarchical}

$$t_{0,ij} = \exp\left(\beta_{\text{ndt},0} + \sum_k \beta_{\text{ndt},k} X_{k,ij}\right)$$ {#eq-ndt-hierarchical}

$$z_{ij} = \text{logit}^{-1}\left(\beta_{\text{bias},0} + \sum_k \beta_{\text{bias},k} X_{k,ij} + u_{\text{bias},i}\right)$$ {#eq-bias-hierarchical}

where $\beta_{0}$ are population-level intercepts, $\beta_k$ are population-level coefficients for predictors $X_k$ (e.g., task, effort condition, difficulty level), and $u_i \sim \mathcal{N}(0, \sigma^2_u)$ are subject-level random effects. Note that $t_0$ is modeled without subject-level random effects to maintain model stability in the response-signal design.

### Likelihood Function

The likelihood for a single trial with RT $t$ and decision $d \in \{\text{"same"}, \text{"different"}\}$ follows the Wiener first-passage time distribution [@feller1968introduction]:

$$p(t, d | v, a, t_0, z) = \text{Wiener}(t - t_0 | v, a, z)$$ {#eq-likelihood}

where the Wiener distribution gives the probability density of the first-passage time to boundary $d$ given drift $v$, boundary separation $a$, and starting point $z \cdot a$.

## Decision Coding

We employed **response-side coding** (also called "stimulus coding" or "response coding") where the upper boundary corresponds to "different" responses and the lower boundary corresponds to "same" responses (see @fig-ddm-process), rather than accuracy-based coding where boundaries represent correct/incorrect responses. This specification is necessary to disentangle *response bias* (a preference for one response alternative regardless of stimulus truth) from *discriminability* (drift rate) [@wiecki2013hddm; @ratcliff2008diffusion].

In accuracy-based coding, bias would imply a preference for being correct (which is conceptually trivial), whereas response-side coding allows us to model the meaningful preference for the "same" response option observed in detection tasks. This is particularly important for same/different discrimination tasks where participants often exhibit specific response biases (e.g., a conservative "same" bias) rather than general accuracy biases. Previous work linking arousal to decision-making has demonstrated that phasic arousal reduces response biases in detection tasks [@deGee2020pupil], and capturing this effect requires mapping boundaries to response alternatives.

On Standard (Δ=0) trials, participants chose "same" on 89.1% of trials and "different" on 10.9%—consistent with a conservative response tendency. The inclusion of Standard trials provides a critical constraint for estimating bias. While Standard trials theoretically have zero objective evidence difference (Δ=0), our model estimated a strong negative drift rate (v ≈ -1.26 in the primary model), indicating that participants actively accumulate evidence toward "same" responses when stimuli are identical. The observed preference for "same" responses reflects the combined effects of both drift and starting-point bias, with drift dominating the decision process. This bias estimate would be unobtainable using accuracy-coded models, where Standard trials would be ambiguous (both "same" and "different" responses are technically correct when stimuli are identical). Response-side coding was implemented directly from the raw data using the `resp_is_diff` column, which explicitly records whether each trial was a "different" response (TRUE) or "same" response (FALSE), ensuring accurate mapping to DDM boundary assignments.

## Computational Methods

All analyses were performed using R version 4.5.2 (2025-10-31) "\[Not\] Part in a Rumble" [@R] on macOS (aarch64-apple-darwin20, Apple Silicon). Bayesian hierarchical models were fitted using `brms` [@burkner2017brms; @burkner2018brms] with CmdStan [@cmdstan2024] via `cmdstanr` [@cmdstanr] as the backend. Model comparison was conducted using leave-one-out cross-validation via the `loo` package [@vehtari2017loo]. Data manipulation and visualization used `dplyr` [@dplyr], `tidyr` [@tidyr], `readr` [@readr], and `ggplot2` [@wickham2016ggplot2]. Tables were generated using `gt` [@gt]. Posterior analysis and diagnostics used the `posterior` package [@burkner2022posterior]. Code development and debugging were performed using Cursor (AI-assisted code editor), and the document was rendered using Quarto [@quarto].

**MCMC Sampling Specifications:**

-   Algorithm: NUTS (No-U-Turn Sampler)
-   Chains: 4
-   Iterations: 8,000 per chain (4,000 warmup, 4,000 sampling)
-   Convergence criteria: $\hat{R}$ ≤ 1.01 [@gelman1992inference; @vehtari2021rank], minimum bulk/tail ESS ≥ 400

## Sample & Experimental Design

### Participants

67 older adults (≥65 years; mean age = 71.3 years, SD = 4.8). This analysis uses the same dataset and participants as described in the LC behavioral report manuscript (see References). All participants provided informed consent and received course credit or financial compensation for participation. Study procedures were approved by the Institutional Review Board of the University of California, Riverside and all experimental procedures were performed in accordance with the approved guidelines and regulations.

*Note*: 12 participants performed at or below chance (≤55%) in some conditions but were retained to maximize sample size, as hierarchical modeling borrows strength to stabilize their estimates. Sensitivity analyses confirmed their inclusion did not alter main effects.

### Tasks and Conditions

**Tasks**: Auditory Detection Task (ADT) and Visual Detection Task (VDT) were modeled jointly with 'task' as a fixed effect. This approach uses a single random effect variance parameter for subject-level variability across both tasks, allowing the model to share information between tasks and stabilize subject-specific estimates through hierarchical shrinkage while estimating task-specific offsets. *\[Detailed task descriptions, stimulus parameters, and equipment specifications are provided in the LC behavioral report manuscript; see References.\]*

**Conditions** (within-subjects, factorial design):

-   **Difficulty**: Standard (Δ=0), Easy, Hard
-   **Effort**: Low (5% MVC), High (40% MVC)

**Total design cells**: 2 tasks × 3 difficulty levels × 2 effort conditions = 12 cells per subject.

**Total trials analyzed**: 17,834 (after exclusions). Standard trials: 3,597 (20.2%).

## Pupillometry Data Preprocessing

Pupil diameter was continuously recorded using an MRI-compatible TRACKPixx binocular eye tracker (VPixx, Montreal, Canada) sampling at 2000 Hz. Raw eye-tracking data were exported as .mat files and processed through a multi-stage preprocessing pipeline designed to ensure high-quality pupillometry measurements. Blink artifacts and invalid samples were removed using the ET-remove-artifacts MATLAB toolbox (Huang et al., 2020), which employs a velocity-based detection algorithm that identifies blink onsets and offsets by detecting peaks and troughs in the filtered derivative of the pupil signal. The algorithm was configured with a 100th-order low-pass filter (passband: 10 Hz, stopband: 12 Hz) and peak/trough threshold factors of 5 standard deviations above baseline to detect blink events. Artifacts exceeding 2 seconds in duration were replaced with missing values rather than interpolated, following best practices for handling extended periods of signal loss. Following automated blink detection, all recordings underwent manual inspection and editing using the toolbox's interactive plot editor to identify and correct any remaining undetected artifacts and ensure proper interpolation across blink events. The manually cleaned pupil data were then trial-aligned using event timestamps extracted from the original recordings, synchronized with behavioral event markers, and downsampled from 2000 Hz to 250 Hz using an 8th-order anti-aliasing filter to preserve signal quality while reducing computational demands. This preprocessing pipeline resulted in artifact-corrected, trial-aligned pupil recordings integrated with behavioral metadata for subsequent statistical analyses.

### Cognitive AUC Window Definition

The cognitive AUC was calculated from **300ms after target stimulus onset until 3.3s post-target** (4.65s to 7.65s relative to squeeze onset), using baseline-corrected pupil data. This window (W3.0) was selected to capture the full task-evoked pupil response (TEPR) peak, which occurs at ~2.95s post-target. 

**Justification for extending into response window**: Due to the 300ms physiological latency and the response window starting only 50ms later (at 4.70s), the cognitive TEPR necessarily unfolds during the response period. The peak response occurs at ~7.30s, well within the response window, indicating that cognitive processing (stimulus comparison, decision-making) continues during active responding.

**Interpretation**: This cognitive AUC should be interpreted as **TEPR magnitude during the decision/response period**, rather than a pure pre-response predictor. For robustness, we also computed an early window (W1.3: target+0.3 to target+1.3s) that minimizes post-response contamination and serves as a sensitivity check.

### Sensitivity Analysis

To address potential concerns about post-response contamination, we computed an early cognitive window (W1.3: target+0.3 to target+1.3s) that extends only 0.95s into the response period. This provides a more conservative estimate of pre-response cognitive processing and serves as a robustness check for our primary analyses.

## Trial Timeline (Response-Signal Design)

@fig-trial-structure shows the task design and trial timeline.

```{r}
#| label: fig-trial-structure
#| fig-cap: "Task design. Both Auditory and Visual tasks followed the same trial structure, but differed in stimuli. Each trial began with a 1.5-4.5 s jittered blank gray screen, followed by a 3 s grip gauge instructing low (5% MVC) or high (40% MVC) force with on-screen feedback. After a 0.25 s blank and 0.5 s fixation, a stimulus pair was presented. Auditory task: a 1000 Hz 0.1 s standard tone, a 0.5 s ISI, then a 0.1 s comparison tone that was either identical or increased by 8, 16, 32, or 64 Hz. Visual task: a central Gabor (1.5 cycles/degree, 0.2 Michelson contrast, 4°) followed by a 0.5 s blank and a second Gabor that was identical or increased in contrast by 0.06, 0.12, 0.24, or 0.48. Participants then released the grip and had 3 s to report \"same\" or \"different,\" followed by 3 s to rate their confidence on their same/different choice (1-4, low to high). All 5 stimulus levels and the 2 grip levels were presented in equal proportions across 150 trials per task, and were presented pseudorandomly."
#| fig-width: 100
#| fig-align: center
knitr::include_graphics(fig_path("Trial_Structure.png"))
```

**RT definition**: Time from response-screen onset (response-signal design). This is a critical methodological detail: RTs are measured from when the response screen appears (after the stimulus presentation period), not from stimulus onset. This design constrains the interpretation of **t₀ (non-decision time) to primarily reflect motor execution and response selection** rather than the sum of encoding + motor time as in traditional RT tasks. The response-signal design rationale is described in detail in the LC behavioral report manuscript.

**Filtering**: The DDM analysis applies a 250 ms lower-bound cutoff for anticipatory responses. While a 150--200 ms cutoff is standard for young adult populations [@whelan2008effective], research consistently demonstrates that older adults exhibit significantly longer non-decision times ($T_{er}$), reflecting age-related slowing in stimulus encoding and motor execution. Specifically, drift diffusion modeling in aging populations estimates that $T_{er}$ is approximately 80--100 ms longer in older adults compared to their younger counterparts [@ratcliff2001aging; @ratcliff2004aging]. Consequently, a 250 ms threshold provides a conservative lower bound that adjusts for this physiological shift, ensuring that excluded trials represent genuine non-decisional reflexes rather than the leading edge of the valid decision distribution [@woods2015age]. During preprocessing, trials with RT \< 200 ms were excluded (see Trial Exclusions section below). No additional trials were excluded at the 250 ms threshold as all remaining trials had RT ≥ 250 ms. The upper bound of 3.000 s reflects the maximum response window in the task design; no upper-bound filtering was applied post-experiment.

### Data Quality Assurance

#### Trial Exclusions

Trial exclusions were applied during data preprocessing. @tbl-trial-exclusions summarizes exclusions by filter type:

```{r}
#| label: tbl-trial-exclusions
#| tbl-cap: "Trial Exclusions Summary"
# Create trial exclusion summary table
trial_exclusions_summary <- tibble(
  Filter_Type = c("Starting trials", "RT < 200 ms", "Missed responses", "Invalid run performance", "Final trials (Preprocessing)", "Restored (Audit)", "Final Analysis N"),
  Trials_Remaining = c(19740, 19495, 19194, 16958, 16958, 17243, 17243),
  Trials_Removed = c(0, 245, 301, 2236, 2782, -285, 0),
  Percentage_Remaining = c(100.0, 98.76, 97.23, 85.91, 85.91, 87.35, 87.35)
) %>%
  mutate(
    Percentage_Removed = round(100 - Percentage_Remaining, 2)
  )

trial_exclusions_summary %>%
  select(Filter_Type, Trials_Remaining, Trials_Removed, Percentage_Remaining, Percentage_Removed) %>%
  gt() %>%
  tab_header(title = md("**Trial Exclusions Summary**")) %>%
  cols_label(
    Filter_Type = "Filter Applied",
    Trials_Remaining = "Trials Remaining",
    Trials_Removed = "Trials Removed",
    Percentage_Remaining = "% Remaining",
    Percentage_Removed = "% Removed"
  ) %>%
  fmt_number(columns = c(Trials_Remaining, Trials_Removed), decimals = 0) %>%
  fmt_number(columns = c(Percentage_Remaining, Percentage_Removed), decimals = 2) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(rows = Filter_Type == "Final Analysis N")
  ) %>%
  tab_footnote(
    footnote = "RT < 200 ms: Anticipatory responses excluded during preprocessing. The DDM analysis used a 250 ms cutoff, but no additional trials were excluded. 285 trials were restored after a decision coding audit confirmed their validity.",
    locations = cells_body(rows = Filter_Type == "RT < 200 ms")
  )
```

**Summary**: Of 19,740 starting trials, 2,782 trials (14.1%) were excluded during preprocessing: - **245 trials (1.2%)** excluded for RT \< 200 ms (anticipatory responses) - **301 trials (1.5%)** excluded for missed responses - **2,236 trials (11.3%)** excluded for invalid run performance

**Final dataset after preprocessing**: 16,958 trials (85.9% retention) from 65 subjects. Additional data processing steps (e.g., decision coding verification, quality checks) resulted in the final analysis dataset of 17,834 trials from 67 subjects. Two additional subjects were included after verification of their data quality during the decision coding audit. The dataset was updated to use the latest raw behavioral data file (`bap_beh_trialdata_v2.csv`) with direct response-side coding from the `resp_is_diff` column. Note: The DDM analysis applies a more conservative 250 ms lower-bound cutoff (see Filtering section above) based on age-related non-decision time shifts, but no additional trials were excluded as all remaining trials had RT ≥ 250 ms.

### Subject Inclusion & Decision Coding Audit

```{r}
# Subject inclusion summary
if (!is.null(qa_subj)) {
  n_subj <- nrow(qa_subj)
  n_sub_chance <- sum(qa_subj$sub_chance_flag, na.rm = TRUE)
  mean_acc <- mean(qa_subj$acc_overall, na.rm = TRUE) * 100
  cat("**Subject Inclusion:**\n")
  cat("- Total subjects:", n_subj, "\n")
  cat("- Sub-chance performers (≤55% accuracy):", n_sub_chance, "\n")
  cat("- Mean overall accuracy:", sprintf("%.1f%%", mean_acc), "\n\n")
}

# Decision coding audit
if (!is.null(qa_decision)) {
  cat("**Decision Coding Audit:**\n")
  cat("- Total trials:", format(qa_decision$n, big.mark=","), "\n")
  cat("- Decision coding mismatches:", qa_decision$mismatches, "\n")
  cat("- Mismatch rate:", sprintf("%.4f", qa_decision$mismatch_rate), "\n")
}
```

**Result**: All 67 subjects were retained; no sub-chance performers were excluded. Decision coding verification confirmed zero mismatches across all trials. Decision coding methodology is discussed in detail in the Decision Coding section above.

### Manipulation Checks

To confirm the experimental manipulations worked as intended, we conducted mixed-effects analyses on accuracy and RT *independent of any DDM assumptions*. **Important**: These analyses are restricted to Easy and Hard trials only (excluding Standard trials). Standard trials are "same" trials (Δ=0), while Easy and Hard are "different" trials with varying stimulus offsets. The difficulty manipulation is only meaningful within "different" trials, where Easy trials use large frequency/contrast offsets and Hard trials use small offsets.

For the manipulation check, we test whether both experimental manipulations work as intended by comparing (1) Easy vs Hard trials for the difficulty manipulation, and (2) Low vs High effort for the effort manipulation, pooled across both tasks (ADT and VDT). This approach validates both core experimental manipulations while maximizing statistical power. Task differences (VDT shows higher accuracy than ADT) are present but are secondary to validating the manipulations themselves.

#### Accuracy: Generalized Linear Mixed Model

**Model**: `decision ~ difficulty + effort + (1 | subject)`, restricted to Easy and Hard trials only (N = 13,771 trials, pooled across ADT and VDT). Reference levels: Easy, Low_5_MVC. Results are shown in @tbl-accuracy-glmm.

```{r}
#| label: tbl-accuracy-glmm
#| tbl-cap: "Accuracy GLMM Results"
if (!is.null(acc_glmm)) {
  # Function to clean up term names for publication (vectorized)
  clean_term_name <- function(term) {
    term <- as.character(term)
    
    # Intercept
    term <- ifelse(term == "(Intercept)", "Intercept", term)
    
    # Step 1: Handle interactions FIRST (on raw R terms)
    # Difficulty × Task interactions
    term <- gsub("difficulty_levelEasy:taskVDT", "Difficulty: Easy × Task: VDT", term)
    term <- gsub("difficulty_levelEasy:taskADT", "Difficulty: Easy × Task: ADT", term)
    term <- gsub("difficulty_levelHard:taskVDT", "Difficulty: Hard × Task: VDT", term)
    term <- gsub("difficulty_levelHard:taskADT", "Difficulty: Hard × Task: ADT", term)
    
    # Effort × Task interactions
    term <- gsub("effort_conditionLow_5_MVC:taskVDT", "Effort: Low (5% MVC) × Task: VDT", term)
    term <- gsub("effort_conditionLow_5_MVC:taskADT", "Effort: Low (5% MVC) × Task: ADT", term)
    term <- gsub("effort_conditionHigh_MVC:taskVDT", "Effort: High (40% MVC) × Task: VDT", term)
    term <- gsub("effort_conditionHigh_MVC:taskADT", "Effort: High (40% MVC) × Task: ADT", term)
    term <- gsub("effort_conditionLow:taskVDT", "Effort: Low × Task: VDT", term)
    term <- gsub("effort_conditionLow:taskADT", "Effort: Low × Task: ADT", term)
    term <- gsub("effort_conditionHigh:taskVDT", "Effort: High × Task: VDT", term)
    term <- gsub("effort_conditionHigh:taskADT", "Effort: High × Task: ADT", term)
    
    # Difficulty × Effort interactions
    term <- gsub("difficulty_levelEasy:effort_conditionLow_5_MVC", "Difficulty: Easy × Effort: Low (5% MVC)", term)
    term <- gsub("difficulty_levelEasy:effort_conditionHigh_MVC", "Difficulty: Easy × Effort: High (40% MVC)", term)
    term <- gsub("difficulty_levelHard:effort_conditionLow_5_MVC", "Difficulty: Hard × Effort: Low (5% MVC)", term)
    term <- gsub("difficulty_levelHard:effort_conditionHigh_MVC", "Difficulty: Hard × Effort: High (40% MVC)", term)
    term <- gsub("difficulty_levelEasy:effort_conditionLow", "Difficulty: Easy × Effort: Low", term)
    term <- gsub("difficulty_levelEasy:effort_conditionHigh", "Difficulty: Easy × Effort: High", term)
    term <- gsub("difficulty_levelHard:effort_conditionLow", "Difficulty: Hard × Effort: Low", term)
    term <- gsub("difficulty_levelHard:effort_conditionHigh", "Difficulty: Hard × Effort: High", term)
    
    # Step 2: Handle main effects (only for terms NOT already processed as interactions)
    # Check if term is NOT already an interaction (doesn't contain ×)
    main_effect_mask <- !grepl(" × ", term)
    
    # Main effects (preserve colons - these separate factor name from level)
    term[main_effect_mask] <- gsub("difficulty_levelEasy", "Difficulty: Easy", term[main_effect_mask])
    term[main_effect_mask] <- gsub("difficulty_levelHard", "Difficulty: Hard", term[main_effect_mask])
    term[main_effect_mask] <- gsub("effort_conditionLow_5_MVC", "Effort: Low", term[main_effect_mask])
    term[main_effect_mask] <- gsub("effort_conditionHigh_MVC", "Effort: High", term[main_effect_mask])
    term[main_effect_mask] <- gsub("effort_conditionLow", "Effort: Low", term[main_effect_mask])
    term[main_effect_mask] <- gsub("effort_conditionHigh", "Effort: High", term[main_effect_mask])
    term[main_effect_mask] <- gsub("taskVDT", "Task: VDT", term[main_effect_mask])
    term[main_effect_mask] <- gsub("taskADT", "Task: ADT", term[main_effect_mask])
    
    # Step 3: For any remaining raw R interactions (not caught above), convert colon to ×
    # Only if term still has raw R format colons (between factor names, not in cleaned format)
    raw_interaction_mask <- grepl("_condition|_level|task", term) & grepl(":", term) & !grepl(" × ", term)
    term[raw_interaction_mask] <- gsub(":", " × ", term[raw_interaction_mask])
    
    return(term)
  }
  
  acc_glmm %>%
    filter(effect == "fixed") %>%
    mutate(
      term_clean = clean_term_name(term),
      estimate_fmt = sprintf("%.2f", estimate),
      p_value_fmt = ifelse(p.value < .001, "<.001", sprintf("%.3f", p.value)),
      ci_fmt = sprintf("[%.2f, %.2f]", conf.low, conf.high)
    ) %>%
    select(term_clean, estimate_fmt, std.error, statistic, p_value_fmt, ci_fmt) %>%
    rename(term = term_clean) %>%
    gt() %>%
    tab_header(title = md("**Accuracy GLMM Results**")) %>%
    cols_label(
      term = "Term",
      estimate_fmt = "β",
      std.error = "SE",
      p_value_fmt = "p",
      ci_fmt = "95% CI"
    )
}
```

**Key findings**:

-   **Hard vs. Easy**: Hard trials showed substantially lower accuracy than Easy (β = -2.97, *p* \< .001). Easy trials had 85.2% accuracy, while Hard trials had 30.5% accuracy (well below chance). This reflects the increased difficulty of detecting small frequency/contrast differences on "different" trials, demonstrating a strong effect of stimulus difference magnitude on discrimination performance.
-   **High vs. Low Effort**: High effort (40% MVC) showed slightly lower accuracy than Low effort (5% MVC) (β = -0.15, *p* = .001). Low effort had 58.5% accuracy, while High effort had 56.8% accuracy. This suggests that the increased physical effort required for High effort trials may interfere with cognitive performance, potentially due to dual-task resource competition between maintaining grip force and performing the discrimination task.

#### RT: Linear Mixed Model on Median RT

**Model**: `rt_median ~ difficulty + effort + (1 | subject)`, restricted to Easy and Hard trials only (N = 13,771 trials, pooled across ADT and VDT). Reference levels: Easy, Low_5_MVC. Results are shown in @tbl-rt-lmm.

```{r}
#| label: tbl-rt-lmm
#| tbl-cap: "RT LMM Results"
if (!is.null(rt_lmm)) {
  # Function to clean up term names for publication (same as accuracy model, vectorized)
  clean_term_name <- function(term) {
    term <- as.character(term)
    
    # Intercept
    term <- ifelse(term == "(Intercept)", "Intercept", term)
    
    # Step 1: Handle interactions FIRST (on raw R terms)
    # Difficulty × Task interactions
    term <- gsub("difficulty_levelEasy:taskVDT", "Difficulty: Easy × Task: VDT", term)
    term <- gsub("difficulty_levelEasy:taskADT", "Difficulty: Easy × Task: ADT", term)
    term <- gsub("difficulty_levelHard:taskVDT", "Difficulty: Hard × Task: VDT", term)
    term <- gsub("difficulty_levelHard:taskADT", "Difficulty: Hard × Task: ADT", term)
    
    # Effort × Task interactions
    term <- gsub("effort_conditionLow_5_MVC:taskVDT", "Effort: Low (5% MVC) × Task: VDT", term)
    term <- gsub("effort_conditionLow_5_MVC:taskADT", "Effort: Low (5% MVC) × Task: ADT", term)
    term <- gsub("effort_conditionHigh_MVC:taskVDT", "Effort: High (40% MVC) × Task: VDT", term)
    term <- gsub("effort_conditionHigh_MVC:taskADT", "Effort: High (40% MVC) × Task: ADT", term)
    term <- gsub("effort_conditionLow:taskVDT", "Effort: Low × Task: VDT", term)
    term <- gsub("effort_conditionLow:taskADT", "Effort: Low × Task: ADT", term)
    term <- gsub("effort_conditionHigh:taskVDT", "Effort: High × Task: VDT", term)
    term <- gsub("effort_conditionHigh:taskADT", "Effort: High × Task: ADT", term)
    
    # Difficulty × Effort interactions
    term <- gsub("difficulty_levelEasy:effort_conditionLow_5_MVC", "Difficulty: Easy × Effort: Low (5% MVC)", term)
    term <- gsub("difficulty_levelEasy:effort_conditionHigh_MVC", "Difficulty: Easy × Effort: High (40% MVC)", term)
    term <- gsub("difficulty_levelHard:effort_conditionLow_5_MVC", "Difficulty: Hard × Effort: Low (5% MVC)", term)
    term <- gsub("difficulty_levelHard:effort_conditionHigh_MVC", "Difficulty: Hard × Effort: High (40% MVC)", term)
    term <- gsub("difficulty_levelEasy:effort_conditionLow", "Difficulty: Easy × Effort: Low", term)
    term <- gsub("difficulty_levelEasy:effort_conditionHigh", "Difficulty: Easy × Effort: High", term)
    term <- gsub("difficulty_levelHard:effort_conditionLow", "Difficulty: Hard × Effort: Low", term)
    term <- gsub("difficulty_levelHard:effort_conditionHigh", "Difficulty: Hard × Effort: High", term)
    
    # Step 2: Handle main effects (only for terms NOT already processed as interactions)
    # Check if term is NOT already an interaction (doesn't contain ×)
    main_effect_mask <- !grepl(" × ", term)
    
    # Main effects (preserve colons - these separate factor name from level)
    term[main_effect_mask] <- gsub("difficulty_levelEasy", "Difficulty: Easy", term[main_effect_mask])
    term[main_effect_mask] <- gsub("difficulty_levelHard", "Difficulty: Hard", term[main_effect_mask])
    term[main_effect_mask] <- gsub("effort_conditionLow_5_MVC", "Effort: Low", term[main_effect_mask])
    term[main_effect_mask] <- gsub("effort_conditionHigh_MVC", "Effort: High", term[main_effect_mask])
    term[main_effect_mask] <- gsub("effort_conditionLow", "Effort: Low", term[main_effect_mask])
    term[main_effect_mask] <- gsub("effort_conditionHigh", "Effort: High", term[main_effect_mask])
    term[main_effect_mask] <- gsub("taskVDT", "Task: VDT", term[main_effect_mask])
    term[main_effect_mask] <- gsub("taskADT", "Task: ADT", term[main_effect_mask])
    
    # Step 3: For any remaining raw R interactions (not caught above), convert colon to ×
    # Only if term still has raw R format colons (between factor names, not in cleaned format)
    raw_interaction_mask <- grepl("_condition|_level|task", term) & grepl(":", term) & !grepl(" × ", term)
    term[raw_interaction_mask] <- gsub(":", " × ", term[raw_interaction_mask])
    
    return(term)
  }
  
  rt_lmm %>%
    filter(effect == "fixed") %>%
    mutate(
      term_clean = clean_term_name(term),
      estimate_fmt = sprintf("%.3f", estimate),
      ci_fmt = sprintf("[%.3f, %.3f]", conf.low, conf.high)
    ) %>%
    select(term_clean, estimate_fmt, std.error, statistic, ci_fmt) %>%
    rename(term = term_clean) %>%
    gt() %>%
    tab_header(title = md("**RT LMM Results**")) %>%
    cols_label(
      term = "Term",
      estimate_fmt = "β (seconds)",
      std.error = "SE",
      ci_fmt = "95% CI"
    )
}
```

**Key findings**:

-   **Hard vs. Easy**: Hard trials were slower than Easy (β = 0.23 s, 95% CI \[0.20, 0.27\]). Easy trials had a median RT of 0.75 s (mean 0.90 s), while Hard trials had a median RT of 1.01 s (mean 1.12 s). This reflects slower decision-making when stimulus differences are smaller and harder to detect.
-   **High vs. Low Effort**: High effort showed no significant difference in RT compared to Low effort (β = 0.02 s, 95% CI \[-0.02, 0.05\]). Low effort had a median RT of 0.86 s (mean 1.00 s), while High effort had a median RT of 0.89 s (mean 1.02 s). The effort manipulation did not significantly affect reaction time, suggesting that the dual-task demands primarily affected accuracy rather than response speed.

**Conclusion**: Both experimental manipulations worked as intended. The **difficulty manipulation** (Easy vs. Hard within "different" trials) showed strong effects on both accuracy and RT in theoretically expected directions: larger stimulus differences (Easy) led to higher accuracy (85.2% vs. 30.5%) and faster RTs (0.75 s vs. 1.01 s median) compared to smaller differences (Hard). The **effort manipulation** (Low vs. High MVC) showed a small but significant effect on accuracy, with High effort slightly reducing accuracy (56.8% vs. 58.5%), likely due to dual-task resource competition. However, effort did not significantly affect RT. These results validate the experimental design prior to DDM analysis.

## Model Specifications

### Standard-Only Bias Calibration Model

To isolate bias identification from drift, we fit a single hierarchical Wiener DDM to *Standard trials only* (3,597 trials from 67 subjects). The model uses parameter-specific formulas to specify how predictors map onto each DDM parameter:

-   **Drift (v)**: `rt | dec(dec_upper) ~ 1 + (1|subject_id)` with relaxed prior `normal(0, 2)` to allow for potential negative drift
-   **Boundary (a/bs)**: `bs ~ 1 + (1|subject_id)` — intercept + subject random effects
-   **Non-decision time (t₀/ndt)**: `ndt ~ 1` — intercept-only (response-signal design)
-   **Bias (z)**: `bias ~ task + effort_condition + (1|subject_id)` — task/effort effects + subject random effects

**Critical constraint on bias**: Starting-point bias ($z$) was allowed to vary by Task and Effort (which are known to the participant pre-trial) but was constrained to be constant across Difficulty levels, as trial difficulty was randomized and thus unknown at the onset of the decision process. This specification reflects the causal structure of the experimental design: participants cannot adjust their starting point based on an unknown future event (trial difficulty). Task differences in bias (if tasks were blocked) and effort differences (if effort was cued) are valid pre-stimulus settings, whereas difficulty-dependent bias would imply participants could anticipate trial difficulty, which contradicts the randomized design.

*Note*: These formulas are all part of **one model** fitted simultaneously. The `bf()` function in `brms` allows specification of separate formulas for each DDM parameter (drift, boundary, non-decision time, bias) within a single hierarchical model.

**Drift prior rationale**: While Standard trials theoretically have zero evidence (Δ=0), we used a relaxed drift prior (`normal(0, 2)`) rather than a tight prior to allow the model to capture any systematic drift patterns that might emerge from the data. This approach recognizes that even on Standard trials, participants may accumulate evidence toward "same" responses, which is consistent with the observed 89.1% "same" response rate. A tight prior forcing drift to zero would be inappropriate if participants are systematically accumulating evidence toward one boundary. The relaxed prior allows the model to estimate drift and bias jointly, with both parameters contributing to the observed choice proportions.

*Note*: An earlier "Joint Confirmation Model" specification included difficulty in the bias formula, but this was methodologically incorrect as trial difficulty is randomized and thus unknown pre-trial. The primary model (described below) uses the correct specification where bias does not vary by difficulty.

### Primary Analysis Model

The primary model is a **single hierarchical Wiener DDM** that includes difficulty effects on v and a, with task and effort as additive factors. The model uses parameter-specific formulas:

-   **Drift (v)**: `rt | dec(dec_upper) ~ difficulty_level + task + effort_condition + (1 + difficulty_level | subject_id)`
-   **Boundary (a/bs)**: `bs ~ difficulty_level + task + (1 | subject_id)`
-   **Non-decision time (t₀/ndt)**: `ndt ~ task + effort_condition` *(no random effects)*
-   **Bias (z)**: `bias ~ task + effort_condition + (1 | subject_id)` — task/effort effects + subject random effects

**Critical constraint on bias**: Starting-point bias ($z$) was allowed to vary by Task and Effort (which are known to the participant pre-trial) but was constrained to be constant across Difficulty levels, as trial difficulty was randomized and thus unknown at the onset of the decision process. This specification reflects the causal structure of the experimental design: participants cannot adjust their starting point based on an unknown future event (trial difficulty). Task differences in bias (if tasks were blocked) and effort differences (if effort was cued) are valid pre-stimulus settings, whereas difficulty-dependent bias would imply participants could anticipate trial difficulty, which contradicts the randomized design.

*Note*: These formulas are all part of **one model** fitted simultaneously. The `bf()` function in `brms` allows specification of separate formulas for each DDM parameter (drift, boundary, non-decision time, bias) within a single hierarchical model. The `dec_upper` variable (1 = "different", 0 = "same") is directly extracted from the raw data `resp_is_diff` column, ensuring accurate response-side coding for boundary assignments.

**Rationale for ndt formula**: In the response-signal design, t₀ primarily reflects motor execution. To avoid identifiability issues and maintain model stability, we modeled t₀ with group-level task and effort effects only, omitting subject-level random effects. The response-signal task design and its implications for DDM parameter interpretation are described in the LC behavioral report manuscript (see References).

### Priors

All priors are weakly informative and set on the link scale:

**Intercepts**:

-   v Intercept \~ Normal(0, 1)
-   bs Intercept \~ Normal(log(1.7), 0.30) → a ≈ 1.7 on natural scale
-   ndt Intercept \~ Normal(log(0.23), 0.12) → t₀ ≈ 230 ms on natural scale
-   bias Intercept \~ Normal(0, 0.5) → z ≈ 0.5 (no bias) on probability scale

**Slopes**:

-   v slopes: Normal(0, 0.6–0.7)
-   bs slopes: Normal(0, 0.25–0.30)
-   bias slopes: Normal(0, 0.35)

**Random effects**:

-   Standard deviations: Student-t(3, 0, 0.30)
-   Correlations: LKJ(2)

**Sampling controls**: NUTS with `adapt_delta = 0.995`, `max_treedepth = 15`. Four chains, 8,000 iterations (4,000 warmup).

#### Prior vs. Posterior for Non-Decision Time

```{r}
#| label: fig-ndt-prior-posterior
#| fig-cap: "t₀ Prior vs Posterior. Prior (gray line) and posterior (blue shaded density) distributions for the t₀ intercept. The prior is Normal(log(0.23), 0.12) on the log scale (≈0.23 s on natural scale). This figure documents prior influence for the response-signal design, where t₀ primarily reflects motor execution rather than encoding time."
#| fig-width: 85
#| fig-align: center
knitr::include_graphics(fig_path("fig_ndt_prior_posterior.pdf"))
```

**Interpretation**: The posterior for t₀ is well-informed by the data while remaining compatible with the weakly informative prior, confirming adequate identifiability for the group-level intercept despite the response-signal design.

## Model Comparison & Diagnostics

### Model Comparison

We compared 10 candidate models varying in how difficulty, task, and effort map onto DDM parameters. Leave-one-out cross-validation (LOO-CV) was used to select the best-fitting model.

#### LOO Summary

@tbl-loo-comparison shows the LOO-CV results for all candidate models.

```{r}
#| label: tbl-loo-comparison
#| tbl-cap: "Model Comparison: LOO-CV Results"
if (!is.null(loo_primary)) {
  # Function to clean model names for publication
  clean_model_name <- function(model) {
    model <- as.character(model)
    
    # Single parameter models
    model <- ifelse(model == "v", "Difficulty → v (drift)", model)
    model <- ifelse(model == "z", "Difficulty → z (bias)", model)
    model <- ifelse(model == "a", "Difficulty → a (boundary)", model)
    
    # Two-parameter combinations
    model <- ifelse(model == "v_z", "Difficulty → v + z", model)
    model <- ifelse(model == "v_a", "Difficulty → v + a", model)
    model <- ifelse(model == "z_a", "Difficulty → z + a", model)
    
    # Three-parameter combination
    model <- ifelse(model == "v_z_a", "Difficulty → v + a + z", model)
    model <- ifelse(model == "v_a_z", "Difficulty → v + a + z", model)
    
    # Model number formats
    model <- gsub("Model3_Difficulty", "Difficulty → v (drift)", model)
    model <- gsub("Model4_Additive", "Additive (v + a + z)", model)
    model <- gsub("Model5_Interaction", "Interaction", model)
    model <- gsub("Model10_Param_v_bs", "v + a parameterized", model)
    
    # Remove common prefixes
    model <- gsub("^Difficulty_on_", "", model)
    model <- gsub("^difficulty_", "", model)
    
    # Format underscores as separators
    model <- gsub("_", " ", model)
    
    return(model)
  }
  
  loo_primary %>%
    mutate(
      model_clean = clean_model_name(model),
      across(where(is.numeric), ~round(.x, 2))
    ) %>%
    select(model_clean, elpd, se, p_loo) %>%
    rename(model = model_clean) %>%
    gt() %>%
    tab_header(title = md("**Model Comparison: LOO-CV Results**")) %>%
    cols_label(
      model = "Model",
      elpd = "ELPD",
      se = "SE",
      p_loo = "P_loo"
    ) %>%
    tab_style(
      style = cell_fill(color = "#E8F4F8"),
      locations = cells_body(rows = 1)
    )
} else {
  cat("LOO comparison data not available.")
}
```

**Winner**: The model with **difficulty → (v + a)** is strongly favored, with bias constrained to be constant across difficulty levels.

-   **ΔELPD vs. v-only**: ≈ +185 (SE ≈ 20)
-   **Stacking weight**: ≈ 0.89
-   **PBMA weight**: ≈ 1.0

**Pareto-k diagnostics**: 1/17,834 observations had k \> 0.7; moment matching was not required.

```{r}
#| label: fig-loo
#| fig-cap: "Model Comparison: Leave-One-Out Cross-Validation. ELPD (Expected Log-Predictive Density) with 95% SE bars by model. The best model (highest ELPD) is indicated with a dashed red line. ΔELPD values (difference from best) are annotated above each point. Larger ELPD indicates better out-of-sample predictive accuracy."
#| fig-width: 90
#| fig-align: center
knitr::include_graphics(fig_path("fig_loo.pdf"))
```

**Interpretation**: The data strongly support a model in which task difficulty modulates drift rate and boundary separation. Starting-point bias is constrained to be constant across difficulty levels (as trials are randomized), but varies by task and effort. Simpler models (e.g., difficulty affecting only drift) are decisively rejected by cross-validation.

### Model Diagnostics

@tbl-convergence-ppc-gate shows convergence diagnostics and PPC gate results.

```{r}
#| label: tbl-convergence-ppc-gate
#| tbl-cap: "Convergence & PPC Gate (Primary Model)"
if (!is.null(publish_gate)) {
  # Create a clean, readable table with proper column names
  gate_clean <- publish_gate %>%
    # Select and rename convergence metrics
    transmute(
      `Max R̂` = if("conv_max_rhat" %in% names(.)) conv_max_rhat else NA_real_,
      `Min Bulk ESS` = if("conv_min_bulk_ess" %in% names(.)) conv_min_bulk_ess else NA_real_,
      `Min Tail ESS` = if("conv_min_tail_ess" %in% names(.)) conv_min_tail_ess else NA_real_,
      `Divergent Transitions` = if("conv_divergences" %in% names(.)) conv_divergences else NA_real_,
      `Max QP RMSE (s)` = if("ppc_subj_max_qp" %in% names(.)) ppc_subj_max_qp else NA_real_,
      `Max KS Statistic` = if("ppc_subj_max_ks" %in% names(.)) ppc_subj_max_ks else NA_real_,
      `% Cells Flagged` = if("ppc_subj_pct_flagged_any" %in% names(.)) ppc_subj_pct_flagged_any else NA_real_,
      `N Flagged / Total` = if("ppc_subj_n_flagged_any" %in% names(.) && "ppc_subj_n_cells" %in% names(.)) {
        paste0(ppc_subj_n_flagged_any, " / ", ppc_subj_n_cells)
      } else NA_character_
    ) %>%
    # Remove columns that are all NA
    select(where(~!all(is.na(.))))
  
  # Create table with spanner headers
  convergence_cols <- intersect(c("Max R̂", "Min Bulk ESS", "Min Tail ESS", "Divergent Transitions"), names(gate_clean))
  ppc_cols <- intersect(c("Max QP RMSE (s)", "Max KS Statistic", "% Cells Flagged", "N Flagged / Total"), names(gate_clean))
  
  gt_table <- gate_clean %>%
    select(all_of(c(convergence_cols, ppc_cols))) %>%
    gt() %>%
    tab_header(title = md("**Convergence & PPC Gate (Primary Model)**"))
  
  # Add spanner headers if we have both sections
  if (length(convergence_cols) > 0 && length(ppc_cols) > 0) {
    gt_table <- gt_table %>%
      tab_spanner(
        label = "MCMC Convergence",
        columns = all_of(convergence_cols),
        level = 1
      ) %>%
      tab_spanner(
        label = "Posterior Predictive Checks",
        columns = all_of(ppc_cols),
        level = 1
      )
  }
  
  # Format numbers appropriately
  gt_table %>%
    fmt_number(
      columns = where(is.numeric) & !matches("Divergent"),
      decimals = 3
    ) %>%
    fmt_number(
      columns = matches("Divergent"),
      decimals = 0
    ) %>%
    fmt_number(
      columns = matches("% Cells"),
      decimals = 1,
      pattern = "{x}%"
    ) %>%
    tab_style(
      style = cell_text(weight = "bold"),
      locations = cells_column_labels()
    ) %>%
    tab_style(
      style = cell_text(weight = "bold"),
      locations = cells_column_spanners()
    )
} else {
  cat("Publish gate data not available.")
}
```

**Convergence criteria**:

-   Max $\hat{R}$ ≤ 1.01 ✓
-   Min bulk ESS ≥ 400 ✓
-   Min tail ESS ≥ 400 ✓
-   Divergent transitions = 0 ✓

**PPC thresholds** (pre-declared):

-   Subject-wise mid-body QP RMSE ≤ 0.09 s
-   \|Δ accuracy\| ≤ 0.05
-   KS statistic ≤ 0.15
-   ≤ 15% of cells flagged

**Result**: The primary model passes all MCMC convergence gates ($\hat{R}$, ESS, divergent transitions). PPC performance is discussed in detail below.

# Results

## Sample Characteristics and Data Quality

### Demographics

@tbl-demographics shows sample demographics.

```{r}
#| label: tbl-demographics
#| tbl-cap: "Sample Demographics"
# Compute demographics from available data
if (!is.null(behavioral_data)) {
  # Try to extract subject-level demographics
  if ("subject_id" %in% names(behavioral_data)) {
    subj_ids <- unique(behavioral_data$subject_id)
    n_subj_final <- length(subj_ids)
  } else if ("sub" %in% names(behavioral_data)) {
    subj_ids <- unique(behavioral_data$sub)
    n_subj_final <- length(subj_ids)
  } else {
    n_subj_final <- 67  # From Methods section
    subj_ids <- NULL
  }
} else {
  n_subj_final <- 67
  subj_ids <- NULL
}

# Try to load demographics file if available
demographics_file_paths <- c(
  "/Users/mohdasti/Documents/LC-BAP/BAP/BAP_Pupillometry/BAP/BAP_DDM/data/LC Aging Subject Data master spreadsheet - demographics.csv",
  file.path(proj_root, "data/analysis_ready/demographics.csv"),
  file.path(proj_root, "data/analysis_ready/subject_data.csv"),
  "data/analysis_ready/demographics.csv"
)

demographics_file <- NULL
for (path in demographics_file_paths) {
  if (file.exists(path)) {
    demographics_file <- path
    break
  }
}

demographics <- NULL
if (!is.null(demographics_file)) {
  tryCatch({
    # Skip first row if it's a header row
    demographics <- read_csv(demographics_file, skip = 1, show_col_types = FALSE)
    # Map column names - the file might have "SUBJECT NUMBER_1" or "AGE AT BAP SESSION 1"
    if ("SUBJECT NUMBER_1" %in% names(demographics)) {
      demographics <- demographics %>% mutate(subject_id = as.character(`SUBJECT NUMBER_1`))
    }
    if ("AGE AT BAP SESSION 1" %in% names(demographics)) {
      demographics <- demographics %>% mutate(age = as.numeric(`AGE AT BAP SESSION 1`))
    }
  }, error = function(e) {
    cat("Error loading demographics:", e$message, "\n")
    NULL
  })
}

# Create demographics table
if (!is.null(demographics) && "age" %in% names(demographics)) {
  demo_table <- demographics %>%
    summarise(
      n = n(),
      age_mean = round(mean(age, na.rm = TRUE), 1),
      age_sd = round(sd(age, na.rm = TRUE), 1),
      age_min = round(min(age, na.rm = TRUE), 0),
      age_max = round(max(age, na.rm = TRUE), 0),
      age_range = paste0(age_min, "-", age_max)
    )
  
  # Add sex/gender if available
  if ("sex" %in% names(demographics) || "gender" %in% names(demographics)) {
    sex_col <- if ("sex" %in% names(demographics)) "sex" else "gender"
    sex_counts <- demographics %>%
      count(!!sym(sex_col)) %>%
      mutate(sex_pct = round(100 * n / sum(n), 1))
    demo_table <- demo_table %>%
      mutate(
        sex_info = paste(paste(sex_counts[[sex_col]], ":", sex_counts$n, "(", sex_counts$sex_pct, "%)"), collapse = "; ")
      )
  }
  
  # Build column labels dynamically based on what exists
  label_list <- list(
    n = "N",
    age_mean = "Age (Mean)",
    age_sd = "Age (SD)",
    age_range = "Age (Range)"
  )
  
  # Only add sex_info label if the column exists
  if ("sex_info" %in% names(demo_table)) {
    label_list$sex_info <- "Sex/Gender"
  }
  
  # Select only columns that exist and format nicely
  demo_cols <- intersect(c("n", "age_mean", "age_sd", "age_range", "sex_info"), names(demo_table))
  demo_table %>%
    select(all_of(demo_cols)) %>%
    gt() %>%
    tab_header(title = md("**Sample Demographics**")) %>%
    cols_label(.list = label_list) %>%
    fmt_number(columns = where(is.numeric) & !matches("n$"), decimals = 1) %>%
    fmt_number(columns = matches("n$"), decimals = 0)
} else {
  # Placeholder table
  tibble(
    Characteristic = c("N", "Age (Mean ± SD)", "Age (Range)", "Sex/Gender", "Education", "Handedness"),
    Value = c(
      as.character(n_subj_final),
      "71.3 ± 4.8 years",
      "65-85 years",
      "To be completed",
      "To be completed",
      "To be completed"
    )
  ) %>%
    gt() %>%
    tab_header(title = md("**Sample Demographics**")) %>%
    cols_label(
      Characteristic = "Characteristic",
      Value = "Value"
    ) %>%
    tab_footnote(
      footnote = "Demographics data file not found. Please add demographics.csv to data/analysis_ready/ with columns: subject_id, age, sex (or gender), education (optional), handedness (optional).",
      locations = cells_body()
    )
}
```

### Sample Size and Data Retention

@tbl-trial-counts shows trial counts by condition.

```{r}
#| label: tbl-trial-counts
#| tbl-cap: "Trial Counts by Condition"
# Compute trial counts by condition
if (!is.null(behavioral_data)) {
  # Standardize column names
  if ("task" %in% names(behavioral_data)) {
    task_col <- "task"
  } else if ("Task" %in% names(behavioral_data)) {
    task_col <- "Task"
  } else {
    task_col <- NULL
  }
  
  if ("difficulty_level" %in% names(behavioral_data)) {
    diff_col <- "difficulty_level"
  } else if ("difficulty" %in% names(behavioral_data)) {
    diff_col <- "difficulty"
  } else {
    diff_col <- NULL
  }
  
  if ("effort_condition" %in% names(behavioral_data)) {
    effort_col <- "effort_condition"
  } else if ("effort" %in% names(behavioral_data)) {
    effort_col <- "effort"
  } else {
    effort_col <- NULL
  }
  
  if (!is.null(task_col) && !is.null(diff_col) && !is.null(effort_col)) {
    subj_col <- if ("subject_id" %in% names(behavioral_data)) "subject_id" else if ("sub" %in% names(behavioral_data)) "sub" else NULL
    
    if (!is.null(subj_col)) {
      trial_counts <- behavioral_data %>%
        group_by(!!sym(task_col), !!sym(diff_col), !!sym(effort_col)) %>%
        summarise(
          n_trials = n(),
          n_subjects = n_distinct(!!sym(subj_col)),
          .groups = "drop"
        ) %>%
        mutate(
          mean_trials_per_subj = round(n_trials / n_subjects, 1),
          Task = case_when(
            !!sym(task_col) == "ADT" ~ "ADT",
            !!sym(task_col) == "VDT" ~ "VDT",
            TRUE ~ as.character(!!sym(task_col))
          ),
          Difficulty = case_when(
            !!sym(diff_col) == "Standard" ~ "Standard",
            !!sym(diff_col) == "Easy" ~ "Easy",
            !!sym(diff_col) == "Hard" ~ "Hard",
            TRUE ~ as.character(!!sym(diff_col))
          ),
          Effort = case_when(
            !!sym(effort_col) == "Low_5_MVC" ~ "Low (5% MVC)",
            !!sym(effort_col) == "High_40_MVC" ~ "High (40% MVC)",
            !!sym(effort_col) == "low" ~ "Low (5% MVC)",
            !!sym(effort_col) == "high" ~ "High (40% MVC)",
            TRUE ~ as.character(!!sym(effort_col))
          ),
          Task_Group = case_when(
            Task == "ADT" ~ "ADT (Auditory Detection Task)",
            Task == "VDT" ~ "VDT (Visual Detection Task)",
            TRUE ~ Task
          )
        ) %>%
        arrange(Task, Difficulty, Effort) %>%
        select(Task_Group, Difficulty, Effort, n_trials, n_subjects, mean_trials_per_subj) %>%
        mutate(
          `Total Trials` = n_trials,
          `N Subjects` = n_subjects,
          `Mean/Subject` = mean_trials_per_subj
        ) %>%
        select(Task_Group, Difficulty, Effort, `Total Trials`, `N Subjects`, `Mean/Subject`)
      
      trial_counts %>%
        gt(groupname_col = "Task_Group") %>%
        tab_header(title = md("**Trial Counts by Condition**")) %>%
        fmt_number(columns = c(`Total Trials`, `N Subjects`), decimals = 0) %>%
        fmt_number(columns = `Mean/Subject`, decimals = 1) %>%
        tab_style(
          style = cell_text(weight = "bold"),
          locations = cells_column_labels()
        ) %>%
        tab_style(
          style = cell_text(weight = "bold", style = "italic"),
          locations = cells_row_groups()
        ) %>%
        tab_options(
          row_group.as_column = FALSE,
          row_group.padding = px(8)
        )
    } else {
      # Fallback if subject column not found
      trial_counts <- behavioral_data %>%
        group_by(!!sym(task_col), !!sym(diff_col), !!sym(effort_col)) %>%
        summarise(
          n_trials = n(),
          .groups = "drop"
        )
      
      trial_counts %>%
        gt() %>%
        tab_header(title = md("**Trial Counts by Condition**"))
    }
  } else {
    # Summary table if columns not found
    tibble(
      Metric = c("Total Subjects", "Total Trials", "Mean Trials/Subject", "Trials Range/Subject"),
      Value = c(
        as.character(n_subj_final),
        "17,834",
        sprintf("%.1f", 17834 / n_subj_final),
        "To be computed"
      )
    ) %>%
      gt() %>%
      tab_header(title = md("**Sample Size Summary**"))
  }
} else {
  # Placeholder
  tibble(
    Metric = c("Total Subjects", "Total Trials", "Mean Trials/Subject"),
    Value = c(
      as.character(n_subj_final),
      "17,834",
      sprintf("%.1f", 17834 / n_subj_final)
    )
  ) %>%
    gt() %>%
    tab_header(title = md("**Sample Size Summary**")) %>%
    tab_footnote(
      footnote = "Behavioral data file not found. Please ensure BAP_analysis_ready_BEHAVIORAL.csv is in data/analysis_ready/",
      locations = cells_body()
    )
}
```

**Summary**: The final analysis included `r n_subj_final` older adults (≥65 years) with a total of 17,834 usable trials after exclusions. Mean age was 71.3 years (SD = 4.8, range: 65-85 years). All participants completed both ADT and VDT tasks under both low-effort (5% MVC) and high-effort (40% MVC) conditions. Twelve participants performed at or below chance (≤55% accuracy) in some conditions but were retained to maximize sample size, as hierarchical modeling borrows strength to stabilize their estimates through shrinkage.

## Behavioral Performance

### Accuracy Descriptives

@tbl-accuracy-by-condition shows accuracy by condition.

```{r}
#| label: tbl-accuracy-by-condition
#| tbl-cap: "Accuracy by Condition (Subject-Level Means)"
# Compute accuracy by condition
if (!is.null(behavioral_data)) {
  # Standardize column names for accuracy
  if ("correct" %in% names(behavioral_data)) {
    acc_col <- "correct"
  } else if ("iscorr" %in% names(behavioral_data)) {
    acc_col <- "iscorr"
  } else if ("accuracy" %in% names(behavioral_data)) {
    acc_col <- "accuracy"
  } else {
    acc_col <- NULL
  }
  
  # Get task, difficulty, effort columns (already standardized above)
  if (!is.null(acc_col) && !is.null(task_col) && !is.null(diff_col) && !is.null(effort_col)) {
    # Get subject ID column
    subj_col <- if ("subject_id" %in% names(behavioral_data)) "subject_id" else if ("sub" %in% names(behavioral_data)) "sub" else NULL
    
    if (!is.null(subj_col)) {
      # Subject-level accuracy by condition
      acc_by_condition <- behavioral_data %>%
        group_by(!!sym(task_col), !!sym(diff_col), !!sym(effort_col), !!sym(subj_col)) %>%
        summarise(
          n_trials = n(),
          n_correct = sum(!!sym(acc_col), na.rm = TRUE),
          accuracy = mean(!!sym(acc_col), na.rm = TRUE),
          .groups = "drop"
        ) %>%
        group_by(!!sym(task_col), !!sym(diff_col), !!sym(effort_col)) %>%
        summarise(
          mean_acc = round(mean(accuracy, na.rm = TRUE) * 100, 1),
          sd_acc = round(sd(accuracy, na.rm = TRUE) * 100, 1),
          median_acc = round(median(accuracy, na.rm = TRUE) * 100, 1),
          min_acc = round(min(accuracy, na.rm = TRUE) * 100, 1),
          max_acc = round(max(accuracy, na.rm = TRUE) * 100, 1),
          n_subjects = n(),
          .groups = "drop"
        ) %>%
        # Clean up labels for display
        mutate(
          Task = case_when(
            !!sym(task_col) == "ADT" ~ "ADT",
            !!sym(task_col) == "VDT" ~ "VDT",
            TRUE ~ as.character(!!sym(task_col))
          ),
          Difficulty = case_when(
            !!sym(diff_col) == "Standard" ~ "Standard",
            !!sym(diff_col) == "Easy" ~ "Easy",
            !!sym(diff_col) == "Hard" ~ "Hard",
            TRUE ~ as.character(!!sym(diff_col))
          ),
          Effort = case_when(
            !!sym(effort_col) == "Low_5_MVC" ~ "Low (5% MVC)",
            !!sym(effort_col) == "High_40_MVC" ~ "High (40% MVC)",
            !!sym(effort_col) == "low" ~ "Low (5% MVC)",
            !!sym(effort_col) == "high" ~ "High (40% MVC)",
            TRUE ~ as.character(!!sym(effort_col))
          )
        )
    
    acc_table_data <- acc_by_condition %>%
      arrange(Task, Difficulty, Effort) %>%
      mutate(
        Task_Group = case_when(
          Task == "ADT" ~ "ADT (Auditory Detection Task)",
          Task == "VDT" ~ "VDT (Visual Detection Task)",
          TRUE ~ Task
        ),
        Difficulty = Difficulty,
        Effort = Effort,
        `Mean %` = mean_acc,
        `SD %` = sd_acc,
        `Median %` = median_acc,
        `Min %` = min_acc,
        `Max %` = max_acc,
        `N` = n_subjects
      ) %>%
      select(Task_Group, Difficulty, Effort, `Mean %`, `SD %`, `Median %`, `Min %`, `Max %`, `N`)
    
    # Create gt table with row groups using groupname_col
    acc_table_data %>%
      gt(groupname_col = "Task_Group") %>%
      tab_header(title = md("**Accuracy by Condition (Subject-Level Means)**")) %>%
      fmt_number(columns = where(is.numeric) & !matches("^N$"), decimals = 1) %>%
      fmt_number(columns = matches("^N$"), decimals = 0) %>%
      tab_style(
        style = cell_text(weight = "bold"),
        locations = cells_column_labels()
      ) %>%
      tab_style(
        style = cell_text(weight = "bold", style = "italic"),
        locations = cells_row_groups()
      ) %>%
      tab_options(
        row_group.as_column = FALSE,
        row_group.padding = px(8)
      )
    } else {
      # Placeholder if subject column not found
      cat("**Accuracy Descriptives**:\n")
      cat("Subject ID column not found. Please ensure data contains: subject_id or sub\n")
    }
  } else {
    # Placeholder if columns not found
    cat("**Accuracy Descriptives**:\n")
    cat("Behavioral data columns not fully identified. Please ensure data contains: correct/iscorr/accuracy, task, difficulty_level, effort_condition, subject_id\n")
  }
} else {
  # Placeholder table with row grouping
  acc_placeholder <- expand_grid(
    task = c("ADT", "VDT"),
    difficulty_level = c("Standard", "Easy", "Hard"),
    effort_condition = c("Low_5_MVC", "High_40_MVC")
  ) %>%
    mutate(
      Task_Group = case_when(
        task == "ADT" ~ "ADT (Auditory Detection Task)",
        task == "VDT" ~ "VDT (Visual Detection Task)",
        TRUE ~ task
      ),
      Difficulty = case_when(
        difficulty_level == "Standard" ~ "Standard",
        difficulty_level == "Easy" ~ "Easy",
        difficulty_level == "Hard" ~ "Hard",
        TRUE ~ difficulty_level
      ),
      Effort = case_when(
        effort_condition == "Low_5_MVC" ~ "Low (5% MVC)",
        effort_condition == "High_40_MVC" ~ "High (40% MVC)",
        TRUE ~ effort_condition
      ),
      `Mean %` = "To be computed",
      `SD %` = "To be computed",
      `Median %` = "To be computed",
      `N` = as.character(n_subj_final)
    ) %>%
    arrange(Task_Group, Difficulty, Effort) %>%
    select(Task_Group, Difficulty, Effort, `Mean %`, `SD %`, `Median %`, `N`)
  
  acc_placeholder %>%
    gt(groupname_col = "Task_Group") %>%
    tab_header(title = md("**Accuracy by Condition (Placeholder)**")) %>%
    tab_style(
      style = cell_text(weight = "bold"),
      locations = cells_column_labels()
    ) %>%
    tab_style(
      style = cell_text(weight = "bold", style = "italic"),
      locations = cells_row_groups()
    ) %>%
    tab_options(
      row_group.as_column = FALSE,
      row_group.padding = px(8)
    ) %>%
    tab_footnote(
      footnote = "Behavioral data file not found. Please ensure BAP_analysis_ready_BEHAVIORAL.csv is in data/analysis_ready/",
      locations = cells_body()
    )
}
```

### Overall Accuracy Summary

@tbl-overall-accuracy shows overall accuracy summary.

```{r}
#| label: tbl-overall-accuracy
#| tbl-cap: "Overall Accuracy Summary"
# Overall accuracy across all conditions
if (!is.null(behavioral_data) && !is.null(acc_col)) {
  subj_col <- if ("subject_id" %in% names(behavioral_data)) "subject_id" else if ("sub" %in% names(behavioral_data)) "sub" else NULL
  
  if (!is.null(subj_col)) {
    overall_acc <- behavioral_data %>%
      group_by(!!sym(subj_col)) %>%
      summarise(
        n_trials = n(),
        n_correct = sum(!!sym(acc_col), na.rm = TRUE),
        accuracy = mean(!!sym(acc_col), na.rm = TRUE),
        .groups = "drop"
      )
  
    overall_summary <- overall_acc %>%
      summarise(
        n_subjects = n(),
        mean_acc = round(mean(accuracy, na.rm = TRUE) * 100, 1),
        sd_acc = round(sd(accuracy, na.rm = TRUE) * 100, 1),
        median_acc = round(median(accuracy, na.rm = TRUE) * 100, 1),
        min_acc = round(min(accuracy, na.rm = TRUE) * 100, 1),
        max_acc = round(max(accuracy, na.rm = TRUE) * 100, 1),
        total_trials = sum(n_trials)
      )
    
    overall_summary %>%
      gt() %>%
      tab_header(title = md("**Overall Accuracy Summary**")) %>%
      cols_label(
        n_subjects = "N Subjects",
        mean_acc = "Mean %",
        sd_acc = "SD %",
        median_acc = "Median %",
        min_acc = "Min %",
        max_acc = "Max %",
        total_trials = "Total Trials"
      ) %>%
      fmt_number(columns = c(mean_acc, sd_acc, median_acc, min_acc, max_acc), decimals = 1) %>%
      fmt_number(columns = c(n_subjects, total_trials), decimals = 0)
  } else {
    # Placeholder if subject column not found
    tibble(
      Metric = c("N Subjects", "Mean Accuracy", "SD", "Median", "Range"),
      Value = c(
        as.character(n_subj_final),
        "To be computed",
        "To be computed",
        "To be computed",
        "To be computed"
      )
    ) %>%
      gt() %>%
      tab_header(title = md("**Overall Accuracy Summary (Placeholder)**"))
  }
} else {
  # Placeholder
  tibble(
    Metric = c("N Subjects", "Mean Accuracy", "SD", "Median", "Range"),
    Value = c(
      as.character(n_subj_final),
      "To be computed",
      "To be computed",
      "To be computed",
      "To be computed"
    )
  ) %>%
    gt() %>%
    tab_header(title = md("**Overall Accuracy Summary (Placeholder)**"))
}
```

### Reaction Time Descriptives

@tbl-global-rt shows global RT characteristics, and @tbl-rt-by-condition shows RT by condition. @fig-rt-distribution shows RT distributions by condition.

```{r}
#| label: tbl-global-rt
#| tbl-cap: "Global RT Characteristics (All Trials)"
# Compute RT descriptives
if (!is.null(behavioral_data)) {
  # Standardize RT column name
  if ("rt" %in% names(behavioral_data)) {
    rt_col <- "rt"
  } else if ("resp1RT" %in% names(behavioral_data)) {
    rt_col <- "resp1RT"
  } else if ("RT" %in% names(behavioral_data)) {
    rt_col <- "RT"
  } else {
    rt_col <- NULL
  }
  
  if (!is.null(rt_col) && !is.null(task_col) && !is.null(diff_col) && !is.null(effort_col)) {
    # Get subject ID column
    subj_col <- if ("subject_id" %in% names(behavioral_data)) "subject_id" else if ("sub" %in% names(behavioral_data)) "sub" else NULL
    
    if (!is.null(subj_col)) {
      # Global RT characteristics
      global_rt <- behavioral_data %>%
        filter(!is.na(!!sym(rt_col)), !!sym(rt_col) > 0) %>%
        summarise(
          n_trials = n(),
          mean_rt = round(mean(!!sym(rt_col), na.rm = TRUE), 3),
          sd_rt = round(sd(!!sym(rt_col), na.rm = TRUE), 3),
          median_rt = round(median(!!sym(rt_col), na.rm = TRUE), 3),
          q25_rt = round(quantile(!!sym(rt_col), 0.25, na.rm = TRUE), 3),
          q75_rt = round(quantile(!!sym(rt_col), 0.75, na.rm = TRUE), 3),
          iqr_rt = round(q75_rt - q25_rt, 3),
          min_rt = round(min(!!sym(rt_col), na.rm = TRUE), 3),
          max_rt = round(max(!!sym(rt_col), na.rm = TRUE), 3)
        )
      
      # Condition-wise RT summary (subject-level medians)
      rt_by_condition <- behavioral_data %>%
        filter(!is.na(!!sym(rt_col)), !!sym(rt_col) > 0) %>%
        group_by(!!sym(task_col), !!sym(diff_col), !!sym(effort_col), !!sym(subj_col)) %>%
        summarise(
          median_rt_subj = median(!!sym(rt_col), na.rm = TRUE),
          mean_rt_subj = mean(!!sym(rt_col), na.rm = TRUE),
          .groups = "drop"
        ) %>%
        group_by(!!sym(task_col), !!sym(diff_col), !!sym(effort_col)) %>%
        summarise(
          mean_rt = round(mean(median_rt_subj, na.rm = TRUE), 3),
          sd_rt = round(sd(median_rt_subj, na.rm = TRUE), 3),
          median_rt = round(median(median_rt_subj, na.rm = TRUE), 3),
          q25_rt = round(quantile(median_rt_subj, 0.25, na.rm = TRUE), 3),
          q75_rt = round(quantile(median_rt_subj, 0.75, na.rm = TRUE), 3),
          iqr_rt = round(q75_rt - q25_rt, 3),
          n_subjects = n(),
          .groups = "drop"
        ) %>%
        # Clean up factor labels for display
        mutate(
          Task = case_when(
            !!sym(task_col) == "ADT" ~ "ADT",
            !!sym(task_col) == "VDT" ~ "VDT",
            TRUE ~ as.character(!!sym(task_col))
          ),
          Difficulty = case_when(
            !!sym(diff_col) == "Standard" ~ "Standard",
            !!sym(diff_col) == "Easy" ~ "Easy",
            !!sym(diff_col) == "Hard" ~ "Hard",
            TRUE ~ as.character(!!sym(diff_col))
          ),
          Effort = case_when(
            !!sym(effort_col) == "Low_5_MVC" ~ "Low (5% MVC)",
            !!sym(effort_col) == "High_40_MVC" ~ "High (40% MVC)",
            !!sym(effort_col) == "low" ~ "Low (5% MVC)",
            !!sym(effort_col) == "high" ~ "High (40% MVC)",
            TRUE ~ as.character(!!sym(effort_col))
          )
        )
      
      # Store global_rt for use in summary text
      assign("global_rt", global_rt, envir = .GlobalEnv)
      
      # Display global RT with cleaner formatting
      global_rt %>%
        transmute(
          `N Trials` = n_trials,
          `Mean (s)` = mean_rt,
          `SD (s)` = sd_rt,
          `Median (s)` = median_rt,
          `IQR (s)` = iqr_rt,
          `Min (s)` = min_rt,
          `Max (s)` = max_rt
        ) %>%
        gt() %>%
        tab_header(title = md("**Global RT Characteristics (All Trials)**")) %>%
        fmt_number(columns = where(is.numeric) & !matches("N Trials"), decimals = 3) %>%
        fmt_number(columns = matches("N Trials"), decimals = 0)
    } else {
      cat("**RT Descriptives**:\n")
      cat("Subject ID column not found. Please ensure data contains: subject_id or sub\n")
    }
  } else {
    cat("**RT Descriptives**:\n")
    cat("RT column not identified. Please ensure data contains: rt/resp1RT/RT column\n")
  }
} else {
  # Placeholder
  tibble(
    Metric = c("N Trials", "Mean RT (s)", "SD (s)", "Median RT (s)", "IQR (s)", "Range (s)"),
    Value = c(
      "17,834",
      "To be computed",
      "To be computed",
      "To be computed",
      "To be computed",
      "To be computed"
    )
  ) %>%
    gt() %>%
    tab_header(title = md("**Global RT Characteristics (Placeholder)**"))
}
```

```{r}
#| label: tbl-rt-by-condition
#| tbl-cap: "RT by Condition (Subject-Level Medians)"
# Condition-wise RT table with row grouping
if (!is.null(behavioral_data) && !is.null(rt_col) && !is.null(task_col) && !is.null(diff_col) && !is.null(effort_col) && exists("rt_by_condition")) {
  rt_table_data <- rt_by_condition %>%
    arrange(Task, Difficulty, Effort) %>%
    mutate(
      Task_Group = case_when(
        Task == "ADT" ~ "ADT (Auditory Detection Task)",
        Task == "VDT" ~ "VDT (Visual Detection Task)",
        TRUE ~ Task
      ),
      Difficulty = Difficulty,
      Effort = Effort,
      `Mean Median (s)` = mean_rt,
      `SD (s)` = sd_rt,
      `Median (s)` = median_rt,
      `IQR (s)` = iqr_rt,
      `N` = n_subjects
    ) %>%
    select(Task_Group, Difficulty, Effort, `Mean Median (s)`, `SD (s)`, `Median (s)`, `IQR (s)`, `N`)
  
  # Create gt table with row groups using groupname_col
  rt_table_data %>%
    gt(groupname_col = "Task_Group") %>%
    tab_header(title = md("**RT by Condition (Subject-Level Medians)**")) %>%
    fmt_number(columns = where(is.numeric) & !matches("^N$"), decimals = 3) %>%
    fmt_number(columns = matches("^N$"), decimals = 0) %>%
    tab_style(
      style = cell_text(weight = "bold"),
      locations = cells_column_labels()
    ) %>%
    tab_style(
      style = cell_text(weight = "bold", style = "italic"),
      locations = cells_row_groups()
    ) %>%
    tab_options(
      row_group.as_column = FALSE,
      row_group.padding = px(8)
    )
} else {
  # Placeholder with row grouping
  expand_grid(
    task = c("ADT", "VDT"),
    difficulty_level = c("Standard", "Easy", "Hard"),
    effort_condition = c("Low_5_MVC", "High_40_MVC")
  ) %>%
    mutate(
      Task_Group = case_when(
        task == "ADT" ~ "ADT (Auditory Detection Task)",
        task == "VDT" ~ "VDT (Visual Detection Task)",
        TRUE ~ task
      ),
      Difficulty = case_when(
        difficulty_level == "Standard" ~ "Standard",
        difficulty_level == "Easy" ~ "Easy",
        difficulty_level == "Hard" ~ "Hard",
        TRUE ~ difficulty_level
      ),
      Effort = case_when(
        effort_condition == "Low_5_MVC" ~ "Low (5% MVC)",
        effort_condition == "High_40_MVC" ~ "High (40% MVC)",
        TRUE ~ effort_condition
      ),
      `Mean Median (s)` = "To be computed",
      `SD (s)` = "To be computed",
      `Median (s)` = "To be computed",
      `IQR (s)` = "To be computed"
    ) %>%
    arrange(Task_Group, Difficulty, Effort) %>%
    select(Task_Group, Difficulty, Effort, `Mean Median (s)`, `SD (s)`, `Median (s)`, `IQR (s)`) %>%
    gt(groupname_col = "Task_Group") %>%
    tab_header(title = md("**RT by Condition (Placeholder)**")) %>%
    tab_style(
      style = cell_text(weight = "bold"),
      locations = cells_column_labels()
    ) %>%
    tab_style(
      style = cell_text(weight = "bold", style = "italic"),
      locations = cells_row_groups()
    ) %>%
    tab_options(
      row_group.as_column = FALSE,
      row_group.padding = px(8)
    )
}
```

```{r}
#| label: fig-rt-distribution
#| fig-cap: "RT Distribution by Condition. Density plots showing empirical RT distributions for each Task × Difficulty × Effort combination. RTs are strongly right-skewed, with most responses occurring in the 0.5-1.5 s range. Easy conditions show faster RTs (peaks shifted left), while Hard and Standard conditions show slower RTs (peaks shifted right). Effort effects are subtle compared to difficulty effects. This distributional pattern justifies the use of median RT for descriptive summaries and supports the DDM's ability to capture both central tendencies and tail behavior."
#| fig-width: 100
#| fig-align: center
# RT distribution figure - improved layout
if (!is.null(behavioral_data) && !is.null(rt_col) && !is.null(task_col) && !is.null(diff_col) && !is.null(effort_col)) {
  rt_plot_data <- behavioral_data %>%
    filter(!is.na(!!sym(rt_col)), !!sym(rt_col) > 0, !!sym(rt_col) <= 3.0) %>%
    mutate(
      Task = case_when(
        !!sym(task_col) == "ADT" ~ "ADT",
        !!sym(task_col) == "VDT" ~ "VDT",
        TRUE ~ as.character(!!sym(task_col))
      ),
      Difficulty = case_when(
        !!sym(diff_col) == "Standard" ~ "Standard",
        !!sym(diff_col) == "Easy" ~ "Easy",
        !!sym(diff_col) == "Hard" ~ "Hard",
        TRUE ~ as.character(!!sym(diff_col))
      ),
      Effort = case_when(
        !!sym(effort_col) == "Low_5_MVC" ~ "Low",
        !!sym(effort_col) == "High_40_MVC" ~ "High",
        !!sym(effort_col) == "low" ~ "Low",
        !!sym(effort_col) == "high" ~ "High",
        TRUE ~ as.character(!!sym(effort_col))
      ),
      Condition = paste(Difficulty, Effort, sep = ", ")
    )
  
  if (nrow(rt_plot_data) > 0) {
    # Order factors for better display
    rt_plot_data <- rt_plot_data %>%
      mutate(
        Difficulty = factor(Difficulty, levels = c("Standard", "Easy", "Hard")),
        Effort = factor(Effort, levels = c("Low", "High")),
        Condition = factor(Condition, levels = c("Standard, Low", "Standard, High", 
                                                  "Easy, Low", "Easy, High",
                                                  "Hard, Low", "Hard, High"))
      )
    
    p <- ggplot(rt_plot_data, aes(x = !!sym(rt_col))) +
      geom_density(color = "black", linewidth = 0.7, fill = "gray80", alpha = 0.3) +
      facet_grid(Task ~ Condition, labeller = labeller(Condition = label_wrap_gen(width = 12))) +
      labs(x = "Reaction Time (s)", y = "Density") +
      theme_minimal(base_size = 11) +
      theme(
        strip.text.x = element_text(size = 9, margin = margin(t = 4, b = 4)),
        strip.text.y = element_text(size = 10, face = "bold", margin = margin(r = 4)),
        strip.background = element_rect(fill = "gray95", color = NA),
        axis.text = element_text(size = 8),
        axis.title = element_text(size = 10),
        panel.grid.minor = element_blank(),
        panel.spacing = unit(0.3, "lines")
      ) +
      scale_x_continuous(limits = c(0, 3), breaks = seq(0, 3, 0.5), expand = c(0, 0.05)) +
      scale_y_continuous(expand = expansion(mult = c(0, 0.1)))
    
    # Return the plot (last expression in chunk)
    p
  } else {
    # Create a placeholder plot if no data
    ggplot() + 
      annotate("text", x = 0.5, y = 0.5, label = "RT distribution plot: Data not available.\nPlease ensure behavioral data contains RT values.", size = 4) +
      theme_void() +
      labs(title = "RT Distribution by Condition (Data Not Available)")
  }
} else {
  # Create a placeholder plot if data columns not found
  ggplot() + 
    annotate("text", x = 0.5, y = 0.5, label = "RT distribution plot: Behavioral data or RT column not found.\nPlaceholder figure will be generated when data is available.", size = 4) +
    theme_void() +
    labs(title = "RT Distribution by Condition (Data Not Available)")
}
```

**Summary**: Reaction times were strongly right-skewed, with overall mean RT = `r if (exists("global_rt")) sprintf("%.3f", global_rt$mean_rt) else "~1.00"` s (SD = `r if (exists("global_rt")) sprintf("%.3f", global_rt$sd_rt) else "~0.40"` s, median = `r if (exists("global_rt")) sprintf("%.3f", global_rt$median_rt) else "~0.88"` s). The IQR was `r if (exists("global_rt")) sprintf("%.3f", global_rt$iqr_rt) else "~0.50"` s, indicating substantial variability. RTs ranged from `r if (exists("global_rt")) sprintf("%.3f", global_rt$min_rt) else "0.25"` s (lower bound after filtering) to `r if (exists("global_rt")) sprintf("%.3f", global_rt$max_rt) else "3.00"` s (response window limit). Easy trials showed faster RTs (median ≈ 0.75 s) compared to Hard trials (median ≈ 1.01 s), consistent with the difficulty manipulation. Effort effects on RT were minimal (median difference < 0.05 s), suggesting that the dual-task demands primarily affected accuracy rather than response speed.

## Pupillometry Descriptives

### Data Quality

@tbl-pupil-quality shows pupillometry data quality metrics.

```{r}
#| label: tbl-pupil-quality
#| tbl-cap: "Pupillometry Data Quality Summary"
# Placeholder for pupil data quality
# This will be populated when pupil analysis is complete
pupil_quality_placeholder <- tibble(
  Metric = c(
    "Subjects with usable pupil data",
    "Mean % valid samples per trial",
    "SD % valid samples per trial",
    "Mean % valid samples per subject",
    "Trials excluded (pupil artifacts)",
    "Mean valid trials per condition"
  ),
  Value = c(
    "To be computed",
    "To be computed",
    "To be computed",
    "To be computed",
    "To be computed",
    "To be computed"
  )
)

pupil_quality_placeholder %>%
  gt() %>%
  tab_header(title = md("**Pupillometry Data Quality Summary**")) %>%
  cols_label(
    Metric = "Metric",
    Value = "Value"
  ) %>%
  tab_footnote(
    footnote = "Pupillometry analysis in progress. This table will be populated with actual data quality metrics once pupil preprocessing and analysis are complete.",
    locations = cells_body()
  )
```

### Baseline Pupil Diameter

@tbl-baseline-pupil shows baseline pupil diameter by condition.

```{r}
#| label: tbl-baseline-pupil
#| tbl-cap: "Baseline Pupil Diameter by Condition"
# Placeholder for baseline pupil with row grouping
baseline_pupil_placeholder <- expand_grid(
  task = c("ADT", "VDT"),
  effort_condition = c("Low_5_MVC", "High_40_MVC")
) %>%
  mutate(
    Task_Group = case_when(
      task == "ADT" ~ "ADT (Auditory Detection Task)",
      task == "VDT" ~ "VDT (Visual Detection Task)",
      TRUE ~ task
    ),
    Effort = case_when(
      effort_condition == "Low_5_MVC" ~ "Low (5% MVC)",
      effort_condition == "High_40_MVC" ~ "High (40% MVC)",
      TRUE ~ effort_condition
    ),
    `Mean (mm)` = "To be computed",
    `SD (mm)` = "To be computed",
    `Median (mm)` = "To be computed",
    `N Subjects` = "To be computed"
  ) %>%
  arrange(Task_Group, Effort) %>%
  select(Task_Group, Effort, `Mean (mm)`, `SD (mm)`, `Median (mm)`, `N Subjects`)

baseline_pupil_placeholder %>%
  gt(groupname_col = "Task_Group") %>%
  tab_header(title = md("**Baseline Pupil Diameter by Condition (Placeholder)**")) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels()
  ) %>%
  tab_style(
    style = cell_text(weight = "bold", style = "italic"),
    locations = cells_row_groups()
  ) %>%
  tab_options(
    row_group.as_column = FALSE,
    row_group.padding = px(8)
  ) %>%
  tab_footnote(
    footnote = "Baseline pupil diameter (tonic arousal) will be computed from ITI periods. Analysis pending.",
    locations = cells_body()
  )
```

### Task-Evoked Pupil Response (TEPR)

@tbl-tepr shows TEPR by condition, and @fig-tepr-timecourse shows the TEPR time course.

```{r}
#| label: tbl-tepr
#| tbl-cap: "Task-Evoked Pupil Response (TEPR) by Condition"
# Placeholder for TEPR with row grouping
tepr_placeholder <- expand_grid(
  task = c("ADT", "VDT"),
  difficulty_level = c("Standard", "Easy", "Hard"),
  effort_condition = c("Low_5_MVC", "High_40_MVC")
) %>%
  mutate(
    Task_Group = case_when(
      task == "ADT" ~ "ADT (Auditory Detection Task)",
      task == "VDT" ~ "VDT (Visual Detection Task)",
      TRUE ~ task
    ),
    Difficulty = case_when(
      difficulty_level == "Standard" ~ "Standard",
      difficulty_level == "Easy" ~ "Easy",
      difficulty_level == "Hard" ~ "Hard",
      TRUE ~ difficulty_level
    ),
    Effort = case_when(
      effort_condition == "Low_5_MVC" ~ "Low (5% MVC)",
      effort_condition == "High_40_MVC" ~ "High (40% MVC)",
      TRUE ~ effort_condition
    ),
    `Mean AUC` = "To be computed",
    `SD AUC` = "To be computed",
    `Mean Peak` = "To be computed",
    `SD Peak` = "To be computed",
    `N Subjects` = "To be computed"
  ) %>%
  arrange(Task_Group, Difficulty, Effort) %>%
  select(Task_Group, Difficulty, Effort, `Mean AUC`, `SD AUC`, `Mean Peak`, `SD Peak`, `N Subjects`)

tepr_placeholder %>%
  gt(groupname_col = "Task_Group") %>%
  tab_header(title = md("**Task-Evoked Pupil Response (TEPR) by Condition (Placeholder)**")) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels()
  ) %>%
  tab_style(
    style = cell_text(weight = "bold", style = "italic"),
    locations = cells_row_groups()
  ) %>%
  tab_options(
    row_group.as_column = FALSE,
    row_group.padding = px(8)
  ) %>%
  tab_footnote(
    footnote = "TEPR (phasic arousal) will be quantified as Area Under the Curve (AUC) and peak amplitude relative to baseline. Analysis pending.",
    locations = cells_body()
  )
```

```{r}
#| label: fig-tepr-timecourse
#| fig-cap: "Task-Evoked Pupil Response (TEPR) Time Course. Grand-average pupil traces (mean ± 95% CI) aligned to response signal onset for Low effort (blue) and High effort (crimson) conditions, separately for ADT (left) and VDT (right). The shaded region indicates the time window used for TEPR quantification. Baseline pupil (pre-stimulus) is shown in the -1 to 0 s window. This figure will be generated once pupillometry analysis is complete."
#| fig-width: 95
#| fig-align: center
# Placeholder for TEPR time course figure
cat("TEPR time course figure: Placeholder. This figure will show grand-average pupil traces aligned to response signal onset, with separate panels for Task (ADT/VDT) and lines for Effort condition (Low/High). Analysis pending.\n")
```

**Summary**: Pupillometry data preprocessing is complete (see Methods section), but descriptive statistics and TEPR quantification are pending. Once analysis is complete, this section will report: (1) data quality metrics (percentage of valid samples, artifact exclusion rates), (2) baseline pupil diameter (tonic arousal) by task and effort condition, (3) task-evoked pupil response (TEPR) amplitude and latency by condition, and (4) exploratory correlations between pupil measures and DDM parameters. These analyses will allow us to link physiological arousal states to the latent decision processes identified by the DDM.

## Bias Estimates (Standard-Only Model)

With the relaxed drift prior, the Standard-only bias model estimated a negative drift rate on Standard trials (posterior mean v = -1.404, 95% CrI \[-1.662, -1.147\]), indicating that participants actively accumulated evidence toward the "same" response option. The starting-point bias was slightly above 0.5 (no bias), with posterior mean z = 0.567, 95% CrI \[0.534, 0.601\], indicating a slight bias toward "different" responses. However, the strong negative drift dominates the decision process, resulting in the observed high proportion (89.1%) of "same" responses. This pattern suggests that the conservative response strategy is driven by evidence processing (perceiving sameness as a signal) rather than a simple shift in starting point. VDT showed less bias toward "different" than ADT on the logit scale, with contrast Δ = -0.179, 95% CrI \[-0.259, -0.101\], P(Δ\>0) \< 0.001, indicating modality-specific differences in response bias. Non-decision time was 233 ms, 95% CrI \[226, 240\], consistent with response-signal motor execution.

@tbl-bias-levels shows bias levels by condition, and @tbl-bias-contrasts shows bias contrasts. @fig-bias-by-task visualizes bias by task modality.

```{r}
#| label: tbl-bias-levels
#| tbl-cap: "Bias Levels (z parameter, natural scale)"
if (!is.null(bias_levels_std)) {
  bias_levels_std %>%
    filter(scale == "prob") %>%
    mutate(
      param_label = case_when(
        param == "bias_ADT_Low" ~ "ADT, Low effort",
        param == "bias_ADT_High" ~ "ADT, High effort",
        param == "bias_VDT_Low" ~ "VDT, Low effort",
        param == "bias_VDT_High" ~ "VDT, High effort",
        TRUE ~ param
      )
    ) %>%
    select(param_label, mean, q2.5, q97.5) %>%
    gt() %>%
    tab_header(title = md("**Bias Levels (z parameter, natural scale)**")) %>%
    cols_label(
      param_label = "Condition",
      mean = "Mean",
      q2.5 = "2.5%",
      q97.5 = "97.5%"
    ) %>%
    fmt_number(columns = c(mean, q2.5, q97.5), decimals = 3)
} else {
  cat("Bias levels data not available.")
}
```

```{r}
#| label: tbl-bias-contrasts
#| tbl-cap: "Bias Contrasts (Standard-Only Model)"
if (!is.null(bias_contr_std)) {
  # Function to clean contrast names
  clean_contrast_name <- function(contrast) {
    contrast <- as.character(contrast)
    
    # Common contrast patterns
    contrast <- gsub("difficulty_levelHard", "Difficulty: Hard", contrast)
    contrast <- gsub("difficulty_levelEasy", "Difficulty: Easy", contrast)
    contrast <- gsub("difficulty_levelStandard", "Difficulty: Standard", contrast)
    contrast <- gsub("taskVDT", "Task: VDT", contrast)
    contrast <- gsub("taskADT", "Task: ADT", contrast)
    contrast <- gsub("effort_conditionLow_Force_5pct", "Effort: Low", contrast)
    contrast <- gsub("effort_conditionHigh_Force_40pct", "Effort: High", contrast)
    contrast <- gsub("effort_conditionLow", "Effort: Low", contrast)
    contrast <- gsub("effort_conditionHigh", "Effort: High", contrast)
    
    # Replace operators
    contrast <- gsub(" - ", " vs. ", contrast)
    contrast <- gsub(" -", " vs.", contrast)
    contrast <- gsub("- ", "vs. ", contrast)
    
    return(contrast)
  }
  
  bias_contr_std %>%
    # Filter to keep only VDT vs. ADT contrast (remove High vs. Low effort contrast)
    # The effort contrast is non-significant and collapses across tasks, which is not meaningful
    # without a task × effort interaction term in the model
    filter(grepl("VDT.*ADT|ADT.*VDT", contrast, ignore.case = TRUE)) %>%
    mutate(
      contrast_clean = clean_contrast_name(contrast),
      across(where(is.numeric), ~round(.x, 3))
    ) %>%
    select(contrast_clean, mean, q2.5, q97.5, Pr_gt_0) %>%
    rename(contrast = contrast_clean) %>%
    gt() %>%
    tab_header(title = md("**Bias Contrasts (Standard-Only Model)**")) %>%
    cols_label(
      contrast = "Contrast",
      mean = "Mean Δ (logit)",
      q2.5 = "2.5%",
      q97.5 = "97.5%",
      Pr_gt_0 = "P(Δ>0)"
    )
} else {
  cat("Bias contrasts data not available.")
}
```

```{r}
#| label: fig-bias-by-task
#| fig-cap: "Starting-Point Bias (z) by Task Modality. Bar plot showing mean bias estimates with 95% credible intervals (error bars) for ADT and VDT tasks. Values above 0.5 indicate bias toward 'Different' (upper boundary). ADT shows higher bias (z = 0.573, 95% CrI: [0.540, 0.604]) compared to VDT (z = 0.534, 95% CrI: [0.501, 0.566]). This task-specific difference in starting-point bias suggests that participants adopt different decision criteria for auditory versus visual discrimination tasks."
#| fig-width: 85
#| fig-align: center
knitr::include_graphics(fig_path("plot2_bias_by_task.png"))
```

The Standard-only bias calibration model (with relaxed drift prior) estimated a negative drift rate on Standard trials (posterior mean v = -1.404, 95% CrI \[-1.662, -1.147\]), indicating that participants actively accumulated evidence toward "same" responses on Standard trials, consistent with the observed 89.1% "same" response rate. The primary model (see Difficulty Effects section) estimated similar negative drift for Standard trials (v ≈ -1.26), confirming this pattern across both models.

## Fixed Effects

### Forest Plots by Task

```{r}
#| label: fig-fixed-effects-adt
#| fig-cap: "Fixed Effects: ADT (Auditory Detection Task). Posterior means (link scale) with 95% CrIs for drift (v), boundary separation (a/bs), and starting-point bias (z). In the additive model, difficulty and effort contrasts are identical for both tasks; only the intercepts differ."
#| fig-width: 90
#| fig-align: center
knitr::include_graphics(fig_path("fig_fixed_effects_ADT.pdf"))
```

```{r}
#| label: fig-fixed-effects-vdt
#| fig-cap: "Fixed Effects: VDT (Visual Detection Task). Posterior means (link scale) with 95% CrIs for drift (v), boundary separation (a/bs), and starting-point bias (z). In the additive model, difficulty and effort contrasts are identical for both tasks; only the intercepts differ."
#| fig-width: 90
#| fig-align: center
knitr::include_graphics(fig_path("fig_fixed_effects_VDT.pdf"))
```

### Summary Table

```{r}
#| label: tbl-fixed-effects
#| tbl-cap: "Fixed Effects Summary (Link Scale)"
if (!is.null(fx_table)) {
  # Function to clean DDM parameter names for publication (robust, vectorized version)
  clean_ddm_parameter <- function(param) {
    param <- as.character(param)
    original <- param
    n <- length(param)
    result <- character(n)
    
    for (i in seq_len(n)) {
      p <- param[i]
      orig <- original[i]
      
      # Determine parameter type from prefix
      param_type <- ""
      if (grepl("^bs_", p)) {
        param_type <- "Boundary (a)"
        p <- gsub("^bs_", "", p)
      } else if (grepl("^bias_", p)) {
        param_type <- "Bias (z)"
        p <- gsub("^bias_", "", p)
      } else if (grepl("^ndt_", p)) {
        param_type <- "Non-decision time (t₀)"
        p <- gsub("^ndt_", "", p)
      } else if (grepl("^b_", p)) {
        param_type <- "Drift (v)"
        p <- gsub("^b_", "", p)
      } else {
        # Try to infer from content
        if (grepl("bs|boundary", orig, ignore.case = TRUE)) {
          param_type <- "Boundary (a)"
        } else if (grepl("ndt|non.decision", orig, ignore.case = TRUE)) {
          param_type <- "Non-decision time (t₀)"
        } else if (grepl("bias", orig, ignore.case = TRUE)) {
          param_type <- "Bias (z)"
        } else {
          param_type <- "Drift (v)"  # Default
        }
      }
      
      # Handle Intercept
      if (p == "Intercept" || orig == "Intercept") {
        result[i] <- paste0(param_type, ": Intercept")
        next
      }
      
      # Handle task-specific parameters that are already formatted (e.g., "Drift (v): ADT")
      # These come from the updated extraction script that computes task-specific intercepts
      if (grepl(": (ADT|VDT)$", orig, ignore.case = TRUE)) {
        result[i] <- orig  # Pass through already-formatted task-specific parameters
        next
      }
      
      # Step 1: Check if this is an interaction (has colon between different factors in raw R format)
      # Interactions have colons between factor patterns like difficulty_level:task or effort_condition:task
      is_raw_interaction <- grepl("_level:", p) || grepl("_condition:", p) || 
                           (grepl("difficulty_level", p) && grepl(":task", p)) ||
                           (grepl("effort_condition", p) && grepl(":task", p)) ||
                           (grepl("difficulty_level", p) && grepl(":effort_condition", p))
      
      if (is_raw_interaction) {
        # Handle interactions: split by colon between factors, clean each part, join with ×
        # Pattern: difficulty_levelHard:taskVDT -> split -> clean -> "Difficulty: Hard × Task: VDT"
        if (grepl(":", p) && !grepl(" × ", p)) {
          # Split by colon (assuming only one colon between factors for interactions)
          parts <- strsplit(p, ":")[[1]]
          # Clean each part
          cleaned_parts <- character(length(parts))
          for (j in seq_along(parts)) {
            part <- parts[j]
            # Clean difficulty
            part <- gsub("difficulty_levelEasy", "Difficulty: Easy", part, ignore.case = TRUE)
            part <- gsub("difficulty_levelHard", "Difficulty: Hard", part, ignore.case = TRUE)
            part <- gsub("difficulty_levelStandard", "Difficulty: Standard", part, ignore.case = TRUE)
            # Clean task
            part <- gsub("^taskVDT$", "Task: VDT", part, ignore.case = TRUE)
            part <- gsub("^taskADT$", "Task: ADT", part, ignore.case = TRUE)
            # Clean effort
            part <- gsub("^effort_conditionLow_Force_5pct$", "Effort: Low", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionLow_MVC$", "Effort: Low", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionLow$", "Effort: Low", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionHigh_Force_40pct$", "Effort: High", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionHigh_MVC$", "Effort: High", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionHigh$", "Effort: High", part, ignore.case = TRUE)
            cleaned_parts[j] <- part
          }
          # Join with ×
          p <- paste(cleaned_parts, collapse = " × ")
        }
      } else {
        # Step 2: Main effects - clean normally (preserve colons)
      # Clean difficulty levels (flexible matching)
      p <- gsub("difficulty_levelEasy", "Difficulty: Easy", p, ignore.case = TRUE)
      p <- gsub("difficulty_levelHard", "Difficulty: Hard", p, ignore.case = TRUE)
      p <- gsub("difficulty_levelStandard", "Difficulty: Standard", p, ignore.case = TRUE)
      
      # Clean task
      p <- gsub("taskVDT", "Task: VDT", p, ignore.case = TRUE)
      p <- gsub("taskADT", "Task: ADT", p, ignore.case = TRUE)
      
      # Clean effort conditions (handle all variations - order matters!)
      p <- gsub("effort_conditionLow_Force_5pct", "Effort: Low", p, ignore.case = TRUE)
      p <- gsub("effort_conditionLow_MVC", "Effort: Low", p, ignore.case = TRUE)
      p <- gsub("effort_conditionLow", "Effort: Low", p, ignore.case = TRUE)
      p <- gsub("effort_conditionHigh_Force_40pct", "Effort: High", p, ignore.case = TRUE)
      p <- gsub("effort_conditionHigh_MVC", "Effort: High", p, ignore.case = TRUE)
      p <- gsub("effort_conditionHigh", "Effort: High", p, ignore.case = TRUE)
      }
      
      # Add parameter type prefix if we have meaningful content
      if (p != orig && param_type != "") {
        # Check if param already starts with a parameter type (avoid duplication)
        if (!grepl("^(Drift|Boundary|Non-decision|Bias)", p)) {
          result[i] <- paste0(param_type, ": ", p)
        } else {
          result[i] <- p
        }
      } else {
        result[i] <- p
      }
    }
    
    return(result)
  }
  
  fx_table %>%
    mutate(
      parameter_clean = clean_ddm_parameter(parameter),
      across(where(is.numeric), ~round(.x, 3))
    ) %>%
    mutate(
      rhat = ifelse(is.na(rhat), "-", sprintf("%.2f", rhat)),
      ess = ifelse(is.na(ess), "-", format(round(as.numeric(ess)), big.mark = ","))
    ) %>%
    select(parameter_clean, estimate, conf.low, conf.high, rhat, ess) %>%
    rename(parameter = parameter_clean) %>%
    gt() %>%
    tab_header(title = md("**Table: Fixed Effects Summary (Link Scale)**")) %>%
    cols_label(
      parameter = "Parameter",
      estimate = "Mean",
      conf.low = "2.5%",
      conf.high = "97.5%",
      rhat = "Rhat",
      ess = "ESS Bulk"
    ) %>%
    tab_style(
      style = cell_text(weight = "bold"),
      locations = cells_column_labels()
    )
} else {
  cat("Fixed effects table not available.")
}
```

### DDM Parameter Descriptives on Natural Scale

To provide interpretable parameter values, we report posterior means and 95% credible intervals on the **natural scale** (after inverse transformation from link scales) for each condition. These values represent the actual drift rates (v, in units/s), boundary separations (a, in arbitrary units), non-decision times (t₀, in seconds), and starting-point biases (z, as proportions). @tbl-ddm-parameters-natural shows DDM parameters on the natural scale by condition.

```{r}
#| label: tbl-ddm-parameters-natural
#| tbl-cap: "DDM Parameters on Natural Scale by Condition"
# Load parameter estimates on natural scale if available
param_natural <- sread(file.path(p, "table_ddm_parameters_natural_scale.csv")) %||%
                 sread(file.path(p, "ddm_parameters_natural.csv"))

if (!is.null(param_natural)) {
  # Display parameters by condition
  if ("condition" %in% names(param_natural) || all(c("task", "difficulty_level", "effort_condition") %in% names(param_natural))) {
    # If condition column exists, use it; otherwise combine task/difficulty/effort
    if (!"condition" %in% names(param_natural)) {
      param_natural <- param_natural %>%
        mutate(condition = paste(task, difficulty_level, effort_condition, sep = "_"))
    }
    
    param_natural %>%
      select(condition, parameter, mean, q2.5, q97.5) %>%
      pivot_wider(names_from = parameter, values_from = c(mean, q2.5, q97.5)) %>%
      gt() %>%
      tab_header(title = md("**DDM Parameters on Natural Scale by Condition**")) %>%
      fmt_number(columns = where(is.numeric), decimals = 3)
  } else {
    # Try to create summary by parameter type
    param_summary <- param_natural %>%
      group_by(parameter) %>%
      summarise(
        mean_overall = round(mean(mean, na.rm = TRUE), 3),
        sd_overall = round(sd(mean, na.rm = TRUE), 3),
        min_val = round(min(mean, na.rm = TRUE), 3),
        max_val = round(max(mean, na.rm = TRUE), 3),
        .groups = "drop"
      )
    
    param_summary %>%
      gt() %>%
      tab_header(title = md("**DDM Parameters on Natural Scale (Overall Summary)**")) %>%
      cols_label(
        parameter = "Parameter",
        mean_overall = "Mean",
        sd_overall = "SD",
        min_val = "Min",
        max_val = "Max"
      ) %>%
      fmt_number(columns = where(is.numeric), decimals = 3)
  }
} else {
  # Placeholder: Create table from fixed effects if available
  if (!is.null(fx_table)) {
    # Extract intercepts and transform to natural scale
    # This is a simplified version - full transformation would require model object
    cat("**DDM Parameters on Natural Scale**:\n")
    cat("Parameter estimates on natural scale will be computed from the model posterior.\n")
    cat("For now, see Fixed Effects table (link scale) and Parameter Contrasts (differences).\n")
    cat("Typical values: Drift (v) ≈ -1.0 to +2.0 units/s; Boundary (a) ≈ 1.5-2.0; ")
    cat("Non-decision time (t₀) ≈ 0.23 s; Bias (z) ≈ 0.50-0.60\n")
  } else {
    # Full placeholder with row grouping
    expand_grid(
      task = c("ADT", "VDT"),
      difficulty_level = c("Standard", "Easy", "Hard"),
      effort_condition = c("Low_5_MVC", "High_40_MVC")
    ) %>%
      mutate(
        Task_Group = case_when(
          task == "ADT" ~ "ADT (Auditory Detection Task)",
          task == "VDT" ~ "VDT (Visual Detection Task)",
          TRUE ~ task
        ),
        Difficulty = case_when(
          difficulty_level == "Standard" ~ "Standard",
          difficulty_level == "Easy" ~ "Easy",
          difficulty_level == "Hard" ~ "Hard",
          TRUE ~ difficulty_level
        ),
        Effort = case_when(
          effort_condition == "Low_5_MVC" ~ "Low (5% MVC)",
          effort_condition == "High_40_MVC" ~ "High (40% MVC)",
          TRUE ~ effort_condition
        ),
        `Drift (v)` = "To be computed",
        `Boundary (a)` = "To be computed",
        `Non-decision (t₀)` = "To be computed",
        `Bias (z)` = "To be computed"
      ) %>%
      arrange(Task_Group, Difficulty, Effort) %>%
      select(Task_Group, Difficulty, Effort, `Drift (v)`, `Boundary (a)`, `Non-decision (t₀)`, `Bias (z)`) %>%
      gt(groupname_col = "Task_Group") %>%
      tab_header(title = md("**DDM Parameters on Natural Scale by Condition (Placeholder)**")) %>%
      tab_style(
        style = cell_text(weight = "bold"),
        locations = cells_column_labels()
      ) %>%
      tab_style(
        style = cell_text(weight = "bold", style = "italic"),
        locations = cells_row_groups()
      ) %>%
      tab_options(
        row_group.as_column = FALSE,
        row_group.padding = px(8)
      ) %>%
      tab_footnote(
        footnote = "Natural scale parameters will be computed by inverse-transforming link-scale estimates. Drift (v) in units/s; Boundary (a) in arbitrary units; Non-decision time (t₀) in seconds; Bias (z) as proportion (0-1).",
        locations = cells_body()
      )
  }
}
```

**Summary**: On the natural scale, the primary model estimated mean drift rates ranging from approximately -1.4 (Standard trials, strong evidence toward "Same") to +0.9 (Easy trials, evidence toward "Different"). Boundary separation averaged approximately 1.7 (SD ≈ 0.3), indicating moderate response caution. Non-decision time averaged 0.23 s (230 ms), consistent with motor execution in the response-signal design. Starting-point bias averaged 0.57 (SD ≈ 0.05), indicating a slight bias toward "Different" responses. These values are consistent with the hierarchical structure of the model and the observed behavioral patterns.

## Parameter Contrasts

@tbl-contrasts shows posterior contrasts with directional probabilities.

```{r}
#| label: tbl-contrasts
#| tbl-cap: "Posterior Contrasts (Directional Probabilities)"
if (!is.null(contrasts_table)) {
  # Handle duplicate column names - CSV may have both q05/q95 and q2.5/q97.5
  # Drop q05/q95 if q2.5/q97.5 exist to avoid duplicates
  if ("q2.5" %in% names(contrasts_table) && "q05" %in% names(contrasts_table)) {
    contrasts_table <- contrasts_table %>% select(-q05)
  }
  if ("q97.5" %in% names(contrasts_table) && "q95" %in% names(contrasts_table)) {
    contrasts_table <- contrasts_table %>% select(-q95)
  }
  # Rename q05/q95 to q2.5/q97.5 if q2.5/q97.5 don't exist
  if ("q05" %in% names(contrasts_table) && !"q2.5" %in% names(contrasts_table)) {
    contrasts_table <- contrasts_table %>% rename(q2.5 = q05)
  }
  if ("q95" %in% names(contrasts_table) && !"q97.5" %in% names(contrasts_table)) {
    contrasts_table <- contrasts_table %>% rename(q97.5 = q95)
  }
  
  # Function to clean contrast and parameter names
  clean_contrast_name <- function(contrast) {
    contrast <- as.character(contrast)
    
    # Common contrast patterns
    contrast <- gsub("difficulty_levelHard", "Difficulty: Hard", contrast)
    contrast <- gsub("difficulty_levelEasy", "Difficulty: Easy", contrast)
    contrast <- gsub("difficulty_levelStandard", "Difficulty: Standard", contrast)
    contrast <- gsub("taskVDT", "Task: VDT", contrast)
    contrast <- gsub("taskADT", "Task: ADT", contrast)
    contrast <- gsub("effort_conditionLow_Force_5pct", "Effort: Low", contrast)
    contrast <- gsub("effort_conditionHigh_Force_40pct", "Effort: High", contrast)
    
    # Replace operators
    contrast <- gsub(" - ", " vs. ", contrast)
    contrast <- gsub(" -", " vs.", contrast)
    contrast <- gsub("- ", "vs. ", contrast)
    
    return(contrast)
  }
  
  # Function to clean DDM parameter names (same as Fixed Effects table, vectorized)
  clean_ddm_parameter <- function(param) {
    param <- as.character(param)
    original <- param
    n <- length(param)
    result <- character(n)
    
    for (i in seq_len(n)) {
      p <- param[i]
      orig <- original[i]
      
      # Determine parameter type from prefix
      param_type <- ""
      if (grepl("^bs_", p)) {
        param_type <- "Boundary (a)"
        p <- gsub("^bs_", "", p)
      } else if (grepl("^bias_", p)) {
        param_type <- "Bias (z)"
        p <- gsub("^bias_", "", p)
      } else if (grepl("^ndt_", p)) {
        param_type <- "Non-decision time (t₀)"
        p <- gsub("^ndt_", "", p)
      } else if (grepl("^b_", p)) {
        param_type <- "Drift (v)"
        p <- gsub("^b_", "", p)
      } else {
        # Try to infer from content
        if (grepl("bs|boundary", orig, ignore.case = TRUE)) {
          param_type <- "Boundary (a)"
        } else if (grepl("ndt|non.decision", orig, ignore.case = TRUE)) {
          param_type <- "Non-decision time (t₀)"
        } else if (grepl("bias", orig, ignore.case = TRUE)) {
          param_type <- "Bias (z)"
        } else {
          param_type <- "Drift (v)"  # Default
        }
      }
      
      # Handle Intercept
      if (p == "Intercept" || orig == "Intercept") {
        result[i] <- paste0(param_type, ": Intercept")
        next
      }
      
      # Handle task-specific parameters that are already formatted (e.g., "Drift (v): ADT")
      # These come from the updated extraction script that computes task-specific intercepts
      if (grepl(": (ADT|VDT)$", orig, ignore.case = TRUE)) {
        result[i] <- orig  # Pass through already-formatted task-specific parameters
        next
      }
      
      # Step 1: Check if this is an interaction (has colon between different factors in raw R format)
      # Interactions have colons between factor patterns like difficulty_level:task or effort_condition:task
      is_raw_interaction <- grepl("_level:", p) || grepl("_condition:", p) || 
                           (grepl("difficulty_level", p) && grepl(":task", p)) ||
                           (grepl("effort_condition", p) && grepl(":task", p)) ||
                           (grepl("difficulty_level", p) && grepl(":effort_condition", p))
      
      if (is_raw_interaction) {
        # Handle interactions: split by colon between factors, clean each part, join with ×
        # Pattern: difficulty_levelHard:taskVDT -> split -> clean -> "Difficulty: Hard × Task: VDT"
        if (grepl(":", p) && !grepl(" × ", p)) {
          # Split by colon (assuming only one colon between factors for interactions)
          parts <- strsplit(p, ":")[[1]]
          # Clean each part
          cleaned_parts <- character(length(parts))
          for (j in seq_along(parts)) {
            part <- parts[j]
            # Clean difficulty
            part <- gsub("difficulty_levelEasy", "Difficulty: Easy", part, ignore.case = TRUE)
            part <- gsub("difficulty_levelHard", "Difficulty: Hard", part, ignore.case = TRUE)
            part <- gsub("difficulty_levelStandard", "Difficulty: Standard", part, ignore.case = TRUE)
            # Clean task
            part <- gsub("^taskVDT$", "Task: VDT", part, ignore.case = TRUE)
            part <- gsub("^taskADT$", "Task: ADT", part, ignore.case = TRUE)
            # Clean effort
            part <- gsub("^effort_conditionLow_Force_5pct$", "Effort: Low", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionLow_MVC$", "Effort: Low", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionLow$", "Effort: Low", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionHigh_Force_40pct$", "Effort: High", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionHigh_MVC$", "Effort: High", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionHigh$", "Effort: High", part, ignore.case = TRUE)
            cleaned_parts[j] <- part
          }
          # Join with ×
          p <- paste(cleaned_parts, collapse = " × ")
        }
      } else {
        # Step 2: Main effects - clean normally (preserve colons)
      # Clean difficulty levels (flexible matching)
      p <- gsub("difficulty_levelEasy", "Difficulty: Easy", p, ignore.case = TRUE)
      p <- gsub("difficulty_levelHard", "Difficulty: Hard", p, ignore.case = TRUE)
      p <- gsub("difficulty_levelStandard", "Difficulty: Standard", p, ignore.case = TRUE)
      
      # Clean task
      p <- gsub("taskVDT", "Task: VDT", p, ignore.case = TRUE)
      p <- gsub("taskADT", "Task: ADT", p, ignore.case = TRUE)
      
      # Clean effort conditions (handle all variations - order matters!)
      p <- gsub("effort_conditionLow_Force_5pct", "Effort: Low", p, ignore.case = TRUE)
      p <- gsub("effort_conditionLow_MVC", "Effort: Low", p, ignore.case = TRUE)
      p <- gsub("effort_conditionLow", "Effort: Low", p, ignore.case = TRUE)
      p <- gsub("effort_conditionHigh_Force_40pct", "Effort: High", p, ignore.case = TRUE)
      p <- gsub("effort_conditionHigh_MVC", "Effort: High", p, ignore.case = TRUE)
      p <- gsub("effort_conditionHigh", "Effort: High", p, ignore.case = TRUE)
      }
      
      # Add parameter type prefix if we have meaningful content
      if (p != orig && param_type != "") {
        # Check if param already starts with a parameter type (avoid duplication)
        if (!grepl("^(Drift|Boundary|Non-decision|Bias)", p)) {
          result[i] <- paste0(param_type, ": ", p)
        } else {
          result[i] <- p
        }
      } else {
        result[i] <- p
      }
    }
    
    return(result)
  }
  
  contrasts_table %>%
    mutate(
      contrast_clean = clean_contrast_name(contrast),
      parameter_clean = clean_ddm_parameter(parameter),
      across(where(is.numeric), ~round(.x, 3))
    ) %>%
    select(contrast_clean, parameter_clean, mean, q2.5, q97.5, p_gt0, p_lt0, p_in_rope) %>%
    rename(contrast = contrast_clean, parameter = parameter_clean) %>%
    gt() %>%
    tab_header(title = md("**Table: Posterior Contrasts (Directional Probabilities)**")) %>%
    cols_label(
      contrast = "Contrast",
      parameter = "Parameter",
      mean = "Mean Δ",
      q2.5 = "2.5%",
      q97.5 = "97.5%",
      p_gt0 = "P(Δ>0)",
      p_lt0 = "P(Δ<0)",
      p_in_rope = "P(in ROPE)"
    ) %>%
    tab_style(
      style = cell_text(weight = "bold"),
      locations = cells_column_labels()
    ) %>%
    tab_footnote(
      footnote = "ROPE (Region of Practical Equivalence): |Δ| < 0.02 for drift (v), |Δ| < 0.05 for boundary (bs) and bias (z) on link scales.",
      locations = cells_column_labels(columns = p_in_rope)
    )
} else {
  cat("Contrasts table not available.")
}
```

**Key contrasts interpreted**:

-   **Easy vs. Hard on drift (v)**: Strong positive effect in both tasks (P(Δ\>0) \> 0.99), indicating faster evidence accumulation for easier discriminations (Mean Δ ≈ +1.50 units/s).
-   **Easy vs. Hard on boundary (a)**: Negative effect (Mean Δ ≈ -0.04 on log scale, or \~4% reduction), consistent with reduced caution.
-   **Task differences**: VDT shows systematically different parameter values than ADT, supporting task-specific processing.
-   **Effort on drift and t₀**: High effort shows small but credible effects on information accumulation and motor execution time (t₀ increase of \~0.03 log-units or \~7.5 ms).

## Individual Differences and Parameter Relationships

### Subject-Level Parameter Distribution

The hierarchical structure of our model allows us to examine individual differences in DDM parameters across participants. Subject-level random effects capture how each participant deviates from the group-level mean for each parameter.

```{r}
#| label: fig-subject-parameter-distribution
#| fig-cap: "Subject-Level Parameter Distribution. Violin plots showing the distribution of subject-level random effects (deviations from group mean) for each DDM parameter. The boxplots within each violin show the median and interquartile range. Zero (dashed line) represents the group mean. This visualization highlights the substantial individual variability in decision-making parameters across our sample of 67 older adults."
#| fig-width: 90
#| fig-align: center
knitr::include_graphics(fig_path("fig_subject_parameter_distribution.pdf"))
```

**Interpretation**: The distributions reveal substantial individual differences in all DDM parameters. Drift rate (v) shows the widest variability, consistent with the heterogeneity in evidence accumulation speed observed in aging populations. Boundary separation (a) and bias (z) also show meaningful individual variation, supporting the use of hierarchical modeling to account for between-subject differences.

### Parameter Correlations

Understanding the relationships between DDM parameters is crucial for interpreting how decision-making components covary. Parameter correlations reveal trade-offs and dependencies that may reflect underlying cognitive strategies.

```{r}
#| label: fig-parameter-correlation
#| fig-cap: "Subject-Level Parameter Correlation: Drift Intercept vs. Bias Intercept. Scatter plot showing the relationship between subject-level drift intercept and bias intercept estimates. Each point represents one subject (n = 67). The correlation is r = -0.205, indicating a weak negative relationship: subjects with stronger negative drift (toward 'Same') tend to have slightly lower bias (closer to 0.5, less bias toward 'Different'). The regression line with 95% confidence interval (shaded ribbon) shows the trend. This pattern suggests that participants who are more sensitive to stimulus identity (stronger negative drift) may also adopt more neutral starting points, potentially reflecting a more conservative decision strategy."
#| fig-width: 85
#| fig-align: center
knitr::include_graphics(fig_path("plot4_parameter_correlation.png"))
```

**Interpretation**: The scatter plot reveals a weak negative correlation (r = -0.205) between drift intercept and bias intercept at the subject level. This suggests that participants who show stronger negative drift (better at detecting "sameness") tend to have less bias toward "Different" responses. While the relationship is modest, it indicates that individual differences in evidence accumulation may be related to differences in starting-point bias, potentially reflecting strategic adaptations in decision criteria across participants.

### Integrated Condition Effects

To provide a comprehensive view of how experimental manipulations affect all DDM parameters simultaneously, we present an integrated visualization of condition effects across parameters.

```{r}
#| label: fig-integrated-condition-effects
#| fig-cap: "Integrated Condition Effects on DDM Parameters. Multi-panel forest plot showing posterior means with 95% credible intervals for difficulty and effort effects on each DDM parameter (drift rate v, boundary separation a, and non-decision time t₀). Note: Bias (z) does not vary by difficulty (see Methods section for rationale). All effects are shown on their respective link scales. This integrated view allows direct comparison of effect magnitudes and directions across parameters, revealing that difficulty primarily affects drift rate and boundary separation, while effort shows smaller effects on drift and non-decision time. Note: Difficulty and effort effects are identical across ADT and VDT due to the additive model structure, so a single combined plot is shown."
#| fig-width: 95
#| fig-align: center
knitr::include_graphics(fig_path("fig_integrated_condition_effects.pdf"))
```

**Interpretation**: The integrated plots reveal that difficulty effects are strongest for drift rate (v) and boundary separation (a), with Easy trials showing faster evidence accumulation and reduced caution relative to Hard trials. Effort effects are more modest but consistent across parameters, with High effort reducing drift rate and increasing non-decision time. These effects are consistent across both ADT and VDT, supporting the additive model structure where difficulty and effort effects are shared across tasks, with only intercepts differing between modalities.

### Brinley Plot: Reaction Time Relationships

Brinley plots are a classic visualization in cognitive aging research that reveal generalized slowing patterns by plotting RT in one condition against RT in another condition [@brinley1965cognitive]. The slope of the regression line indicates the degree of generalized slowing, with slopes > 1 indicating disproportionate slowing in more difficult conditions.

```{r}
#| label: fig-brinley-plot
#| fig-cap: "Brinley Plot: Reaction Time Relationships. Scatter plot showing mean RT for Hard trials (y-axis) versus Easy trials (x-axis) for each participant, colored by effort condition (blue = Low effort, crimson = High effort). Reaction times are displayed in milliseconds (ms). The dashed diagonal line (slope = 1) represents proportional slowing (equal RT increase in both conditions). The solid black regression line shows the actual relationship with 95% confidence interval (shaded ribbon), with slope > 1 indicating disproportionate slowing in Hard trials relative to Easy trials. Points above the diagonal indicate participants who slowed more in Hard relative to Easy trials. This visualization connects our DDM findings to the broader cognitive aging literature on generalized slowing [@brinley1965cognitive; @cerella1985; @salthouse1996]."
#| fig-width: 85
#| fig-align: center
knitr::include_graphics(fig_path("fig_brinley_plot.pdf"))
```

**Interpretation**: The Brinley plot reveals a strong positive relationship between Easy and Hard RTs, with a slope > 1 indicating disproportionate slowing in Hard trials—a hallmark of generalized slowing in older adults [@cerella1985; @salthouse1996]. The scatter of points around the regression line reflects individual differences in the magnitude of difficulty effects, consistent with the heterogeneity in drift rate effects observed in our DDM analysis. The separation by effort condition suggests that high effort may exacerbate the difficulty effect for some participants, though this pattern requires further investigation.

## Model Convergence & Selection

All parameters converged well (max $\hat{R}$ ≤ 1.01; min bulk/tail ESS ≥ 400; no divergent transitions). Leave-one-out cross-validation strongly favored a model in which **difficulty modulates drift and boundary separation jointly** (v+a), with starting-point bias constrained to be constant across difficulty levels (reflecting the randomized trial design), relative to drift-only or simpler models (ΔELPD ≈ +185, SE ≈ 20).

## Difficulty Effects

**Drift rate (v)**: Easy trials show faster evidence accumulation than Hard trials (strong positive contrast, P(Δ\>0) \> 0.99 for both tasks).

```{r}
#| label: fig-drift-rate-difficulty
#| fig-cap: "Drift Rate (v) Across Difficulty Levels. Forest plot showing drift rate estimates with 95% credible intervals for Standard (Δ=0), Hard (Low Signal), and Easy (High Signal) trials. Positive values indicate drift toward 'Different' (upper boundary); negative values indicate drift toward 'Same' (lower boundary). Standard trials show strong negative drift (v ≈ -1.23), indicating participants actively accumulate evidence toward 'Same' responses when stimuli are identical. Hard trials also show negative drift (v ≈ -0.64), indicating weak evidence for difference that is insufficient to overcome the tendency toward 'Same', explaining the below-chance accuracy (~30%). Easy trials show positive drift (v ≈ +0.90), enabling accurate discrimination. This pattern demonstrates the dramatic impact of stimulus discriminability on evidence accumulation."
#| fig-width: 85
#| fig-align: center
knitr::include_graphics(fig_path("plot1_drift_rate_by_difficulty.png"))
```

**Boundary separation (a)**: Easy trials have narrower decision boundaries, consistent with reduced caution when discrimination is easier.

## Task Differences (ADT vs. VDT)

ADT and VDT are separate experimental conditions with distinct parameter profiles. VDT shows systematically different drift rates and boundary settings compared to ADT, supporting modality-specific processing strategies.

## Effort Effects

High effort (40% MVC) produces small but credible effects on drift rate and non-decision time, suggesting that physical effort modulates both information accumulation and motor execution speed.

## Model Fit

**Absolute fit**: Subject-wise mid-body PPCs show acceptable error magnitudes (QP RMSE ≤ 0.09 s for most cells; ≤15% flagged). The model captures central RT tendencies and accuracy well.

**PPC Summary (Joint Model)**: PPCs were good for Standard and Easy cells (QP RMSE \< 0.13, KS \< 0.08), with modest misfit in VDT-Hard (worst QP RMSE ≈ 0.206). This pattern suggests some residual fast-tail behavior not captured by a constant-drift Wiener process.

```{r}
#| label: fig-pdiff-heatmap
#| fig-cap: "Observed vs. model-predicted p('different') across 12 cells (Task × Effort × Difficulty)."
#| fig-width: 90
#| fig-align: center
knitr::include_graphics(fig_path("fig_pdiff_heatmap.png"))
```

```{r}
#| label: fig-ppc-small-multiples
#| fig-cap: "PPC best/median/worst cells (QP RMSE and KS with thresholds)."
#| fig-width: 90
#| fig-align: center
knitr::include_graphics(fig_path("fig_ppc_small_multiples.png"))
```

**Known limitation**: Pooled conditional PPCs reveal residual fast-tail misfit, most pronounced in Easy/VDT conditions. This is a known limitation of constant-drift Wiener DDMs without across-trial variability (sv, sz, st₀) or explicit contaminant/lapse processes.

## Model Validation: Parameter Consistency and Sanity Checks

To validate the internal consistency of our model estimates, we performed three sanity checks recommended by independent expert review. These checks verify that parameter estimates are mathematically consistent with observed behavioral patterns.

### RT Asymmetry on Standard Trials

On Standard trials, the model estimated a strong negative drift rate (v = -1.404) toward "Same" responses, combined with a slight starting-point bias toward "Different" (z = 0.567). To verify the consistency of these estimates, we examined whether RT patterns align with model predictions.

```{r}
#| label: fig-sanity-rt-asymmetry
#| fig-cap: "RT Distribution by Response Type on Standard Trials. Density plots showing reaction time distributions for \"Same\" (crimson) and \"Different\" (blue) responses on Standard (Δ=0) trials. \"Same\" responses were 293 ms faster on average (mean RT = 1.03 s) than \"Different\" responses (mean RT = 1.32 s). This pattern is consistent with strong negative drift: when participants rapidly accumulate evidence for identity, they reach the \"Same\" boundary quickly, resulting in fast RTs. \"Different\" responses (errors) occur less frequently and typically require more time, possibly reflecting near-deadline responses when the process fails to reach the \"Same\" boundary before the response window closes."
#| fig-width: 85
#| fig-align: center
knitr::include_graphics(fig_path("sanity_check1_rt_asymmetry.png"))
```

**Result**: "Same" responses were significantly faster than "Different" responses (mean RT: 1.03 s vs. 1.32 s, difference = 293 ms). This pattern aligns perfectly with the model's prediction: strong negative drift causes rapid evidence accumulation toward "Same", resulting in fast "Same" responses. The slower "Different" responses likely reflect rare errors that occur when the process fails to reach the "Same" boundary within the response window.

### Hard Trial Drift Direction

The primary model estimated that Hard trials have negative drift relative to Standard trials. To verify this estimate is consistent with observed below-chance accuracy on Hard trials, we examined the posterior distribution of Hard trial drift rates.

```{r}
#| label: fig-sanity-hard-drift
#| fig-cap: "Posterior Distribution of Hard Trial Drift Rate. Density plot showing the posterior distribution of drift rate (v) for Hard trials. The mean drift rate is -0.643 (95% CrI: [-0.740, -0.546]), with 100% of posterior draws below zero. This confirms that Hard trials have negative drift toward \"Same\" responses, explaining why participants choose \"Same\" approximately 70% of the time even when stimuli differ. The weak sensory evidence for difference (small stimulus offsets) is insufficient to overcome the baseline tendency to see stimuli as identical."
#| fig-width: 85
#| fig-align: center
knitr::include_graphics(fig_path("sanity_check2_hard_drift.png"))
```

**Result**: Hard trials show consistently negative drift (mean v = -0.643, 95% CrI: [-0.740, -0.546], P(v < 0) = 100%). This confirms that the sensory evidence for difference on Hard trials is too weak to overcome the baseline tendency toward "Same", explaining the observed below-chance accuracy (~30%) on Hard trials.

### Subject Heterogeneity in Drift Rates

The discrepancy between analytical predictions (using group-level mean parameters) and PPC results (using full posterior with subject heterogeneity) suggests substantial individual differences in drift rates. To verify this, we examined the distribution of subject-level drift rate estimates.

```{r}
#| label: fig-sanity-subject-heterogeneity
#| fig-cap: "Distribution of Subject-Level Drift Rates on Standard Trials. Histogram showing the distribution of subject-specific drift rate estimates (deviations from group mean) for Standard trials. The distribution shows substantial heterogeneity (SD = 0.65, range: -3.08 to -0.21), with most subjects showing strong negative drift (|v| ≥ 1.0) but a small subset (4.5%) showing weak drift (|v| < 0.5). This heterogeneity explains why the analytical formula (using group means) under-predicts error rates compared to PPC (which respects individual differences), consistent with Jensen's Inequality in hierarchical models."
#| fig-width: 85
#| fig-align: center
knitr::include_graphics(fig_path("sanity_check3_subject_heterogeneity.png"))
```

**Result**: Subject-level drift rates show substantial heterogeneity (SD = 0.65, range: -3.08 to -0.21). Most subjects (60%) show strong negative drift (|v| ≥ 1.0), while a small subset (4.5%) show weak drift (|v| < 0.5). This heterogeneity explains the PPC vs. analytical formula discrepancy: subjects with weaker drift contribute disproportionately to error rates, but their contribution is masked when using group-level mean parameters.

**Conclusion**: All three sanity checks confirm the internal consistency of our model estimates. RT patterns, drift directions, and individual differences align with model predictions, providing strong evidence that the hierarchical DDM accurately captures the decision-making processes in our data.

# Posterior Predictive Checks

## PPC Validation Method

Posterior Predictive Checks (PPC) were performed to validate model fit by comparing observed data to data simulated from the fitted model. To avoid aggregation bias (Jensen's Inequality) inherent in using group-level mean parameters in non-linear formulas, we used full posterior predictive sampling that respects subject-level random effects [@vehtari2020rank]. This approach generates predictions for every trial in the dataset, maintaining the hierarchical structure of the model.

**PPC Implementation**: For the primary model, we generated 1,000 posterior predictive draws using `brms::posterior_predict()` with `negative_rt = TRUE` to obtain signed reaction times (positive RT = "Different"/upper boundary, negative RT = "Same"/lower boundary). This parameter is critical for correctly extracting choice predictions from `brms` Wiener models. For each draw, we computed the proportion of "Different" responses and compared the distribution of predicted proportions to the observed proportion in the data.

**PPC Results**: On Standard trials, the model accurately predicted choice proportions: observed 10.9% "Different" responses vs. predicted 11.2% (95% credible interval: [9.9%, 12.7%]). The difference of 0.3% falls well within acceptable ranges, confirming that the model captures the data distribution accurately. The observed value falls within the 95% credible interval, indicating excellent model fit.

```{r}
#| label: fig-ppc-validation
#| fig-cap: "Posterior Predictive Check: Choice Proportions on Standard Trials. Histogram showing the distribution of predicted proportions of 'Different' responses across 500 posterior predictive draws. The red dashed vertical line indicates the observed proportion (10.9%), and the blue solid line indicates the mean predicted proportion (11.2%). The orange dotted lines show the 95% credible interval ([9.9%, 12.7%]). The observed value falls well within the predicted distribution, confirming that the hierarchical model accurately captures the data structure and avoids aggregation bias (Jensen's Inequality) by respecting subject-level heterogeneity."
#| fig-width: 85
#| fig-align: center
knitr::include_graphics(fig_path("plot3_ppc_validation.png"))
```

## Primary PPC Gate: Subject-Wise Mid-Body Quantiles

Our **primary gate** for model acceptance is the subject-wise mid-body PPC (conditional on response, 2% censored). This metric respects individual differences and focuses on the core of the RT distribution, avoiding the Simpson's paradox issues inherent in pooled metrics and the known fast-tail limitations of the base Wiener DDM.

**Thresholds** (pre-declared):

-   QP RMSE fail \> 0.12 s (warn \> 0.09 s)
-   KS statistic fail \> 0.20 (warn \> 0.15)
-   Target: ≤ 15% of cells flagged

@tbl-ppc-subj-cens shows subject-wise mid-body PPC results, and @tbl-ppc-subj-summary shows the summary.

```{r}
#| label: tbl-ppc-subj-cens
#| tbl-cap: "Subject-Wise Mid-Body PPC (30/50/70% quantiles; censored 2%)"
if (!is.null(ppc_subj_cens)) {
  ppc_subj_cens %>%
    mutate(across(where(is.numeric), ~round(.x, 3))) %>%
    gt() %>%
    tab_header(title = md("**Subject-Wise Mid-Body PPC (30/50/70% quantiles; censored 2%)**"))
} else {
  cat("Subject-wise PPC data not available.")
}
```

```{r}
#| label: tbl-ppc-subj-summary
#| tbl-cap: "Subject-Wise PPC Summary"
if (!is.null(pf_subj) && !is.na(pf_subj$n_cells)) {
  tibble(
    Metric = c("N Cells", "N Flagged", "% Flagged"),
    Value = c(
      as.character(pf_subj$n_cells),
      as.character(pf_subj$n_flagged),
      sprintf("%.1f%%", pf_subj$pct_flagged)
    )
  ) %>%
    gt() %>%
    tab_header(title = md("**Subject-Wise PPC Summary**"))
}
```

**Result**: `r if (!is.null(pf_subj)) sprintf("%.1f%%", pf_subj$pct_flagged)` of cells flagged. The subject-wise mid-body PPC gate (based on strict pooled quantiles) was not met due to fast-tail deviations. However, as detailed below, the joint model cell-wise PPCs show that the model captures the central tendencies for the majority of conditions (Standard/Easy), with misfit primarily concentrated in VDT-Hard.

## Visual Diagnostics

### 1. RT Distribution Overlays

```{r}
#| label: fig-ppc-rt-overlay
#| fig-cap: "Posterior Predictive Check: RT Distributions. Empirical (black solid) vs. posterior predictive (blue solid) RT densities by Task × Effort × Difficulty. Overall model fit is good for central tendencies, with some misfit in fast tails (especially Easy/VDT)."
#| fig-width: 95
#| fig-align: center
knitr::include_graphics(fig_path("fig_ppc_rt_overlay.pdf"))
```

### Quantile-Probability (QP) Plots

```{r}
#| label: fig-qp-plot
#| fig-cap: "Quantile-Probability (QP) Plot. Empirical vs. predicted RT quantiles by difficulty level, with separate panels for Task × Effort. Points colored by difficulty (Standard=gray, Easy=blue, Hard=red) and shaped by response type (Correct/Error). Dashed diagonal = perfect prediction. Deviations primarily occur in fast tails for Easy/VDT conditions."
#| fig-width: 95
#| fig-align: center
knitr::include_graphics(fig_path("fig_qp.pdf"))
```

### Sensitivity Analyses

We conducted additional sensitivity analyses (Unconditional Pooled PPC, Conditional Pooled PPC) which confirmed that the core findings are robust, though strict pooled metrics flag more cells due to fast-tail misfit. These additional checks are detailed in the Supplementary Figures.

# Discussion

## Summary of Key Findings

Our hierarchical drift-diffusion model revealed that high physical effort (40% MVC) significantly reduced drift rates ($v$) and slowed non-decision time ($t_0$), but did not increase boundary separation ($a$). This pattern of results confirms the "detrimental impact" hypothesis grounded in Resource Competition theory [@azer2023; @wickens2008], which predicts that concurrent physical effort consumes shared cognitive resources, degrading the quality of evidence accumulation. However, the null effect on boundary separation challenges the "adaptive caution" hypothesis (Strategic Adaptation), which predicted that older adults would respond to increased internal noise by raising their decision thresholds to preserve accuracy.

## The "Crunch Point": Why Drift Rate Declined

Our finding that high physical effort significantly reduced drift rates—indicating slower and noisier information accumulation—challenges simple arousal-facilitation accounts and aligns more closely with resource-depletion models. Specifically, the observed decline in processing efficiency supports the **Compensation-Related Utilization of Neural Circuits Hypothesis (CRUNCH)** [@reuterlorenz2008]. The CRUNCH model posits that while older adults can effectively recruit compensatory neural resources to meet lower task demands, they hit a resource ceiling or "crunch point" at lower levels of objective difficulty than younger adults. Once this threshold is crossed, compensatory mechanisms fail, and performance declines precipitously. In the present study, the 40% MVC condition likely pushed participants beyond this critical tipping point. Rather than acting as a beneficial arousal boost that "sharpens" neural gain (as predicted by Adaptive Gain Theory for moderate levels; [@astonjones2005]), the sustained high-effort requirement consumed the limited cognitive resources available for evidence accumulation, resulting in the observed degradation of drift rate.

```{r}
#| label: fig-decision-landscape
#| fig-cap: "The Decision Landscape: Effect of Drift Rate on RT Distribution. This 3D surface visualizes the theoretical 'Crunch Point' observed in our data. The vertical axis (Z) represents the probability density of a response. As Drift Rate (v, Y-axis) decreases from Easy levels (~2.0) to Hard/Standard levels (~0 to -1.0), the sharp peak of timely responses collapses into a flat, spread-out distribution. This visualizes why older adults' reaction times become disproportionately variable and slow when physical effort or task difficulty degrades the quality of evidence accumulation (drift)."
#| fig-width: 100
#| fig-align: center
knitr::include_graphics(fig_path("fig_decision_landscape_3d.png"))
```

## The "Dual-Task Cost": Why Non-Decision Time Slowed

Contrary to the expectation that arousal-induced motor facilitation might speed up response execution, we observed a slowing of non-decision time ($t_0$) under high effort. This result is best understood through the framework of **Cognitive-Motor Interference (CMI)** [@seidler2010motor; @woollacott2002]. In healthy aging, motor control processes—such as maintaining a precise isometric grip—become less automatic and increasingly reliant on executive attentional resources, a phenomenon known as dedifferentiation [@seidler2010motor]. Consequently, the "physical" task of gripping competes directly with the "cognitive" task of motor planning and response selection. In our dual-task paradigm, the attentional demand required to maintain the 40% MVC force likely drew upon the same shared resource pool needed to initiate the button press, creating a bottleneck that manifested as a prolongation of the non-decision component ($t_0$). This suggests that for older adults, concurrent physical exertion acts less as a passive background state and more as an active dual-task stressor that interferes with the efficiency of the motor loop.

## Strategic Rigidity: Why Caution ($a$) Didn't Increase

Despite the internal noise introduced by high effort (as evidenced by reduced drift rates), older adults failed to dynamically adjust their decision criteria by increasing boundary separation ($a$). This null finding suggests *strategic rigidity* in aging: older adults may have difficulty flexibly modulating their decision thresholds in response to changing task demands, even when such adaptation would be beneficial. This rigidity could reflect reduced executive flexibility or a tendency to maintain a fixed "safety-first" strategy regardless of context. While older adults are generally risk-averse and prioritize accuracy [@starns2010], the failure to increase caution under conditions of degraded evidence quality may indicate that the cognitive resources needed for strategic adjustment are themselves depleted by the dual-task demands of the high-effort condition.

## Bias and Phasic Arousal

Regarding starting-point bias ($z$), our results revealed a consistent conservative bias across conditions, with a posterior mean of $z = 0.567$ (95% CrI [0.534, 0.601]) on Standard trials, indicating a slight preference for "different" responses. This bias was robust across effort conditions, with no significant effect of effort level (High vs. Low contrast: Δ = 0.048, 95% CrI [-0.025, 0.120], P(Δ>0) = 0.903). However, we did observe a significant task difference: VDT showed less bias toward "different" than ADT (Δ = -0.179, 95% CrI [-0.259, -0.101], P(Δ>0) < 0.001), suggesting modality-specific differences in response tendencies.

These findings can be interpreted in the context of LC-NE system dynamics. Recent work suggests that phasic arousal, indexed by pupil dilation, can suppress pre-existing choice biases, "resetting" the decision process to a neutral state [@deGee2020pupil]. In our study, the lack of a significant effort effect on bias suggests that the high-effort manipulation (40% MVC) may not have elicited strong enough phasic arousal responses to modulate starting-point bias, or that any such effects were offset by other factors. Alternatively, the integrity of the LC-NE system in our older adult sample may have moderated the expected bias suppression [@huang2024]. The task-specific bias differences (VDT < ADT) may reflect inherent differences in how auditory versus visual detection tasks engage response strategies, independent of arousal state. Future work integrating direct pupillometry measures will be needed to test whether effort-induced phasic arousal responses are indeed present but insufficient to shift bias, or whether the LC-NE system's responsiveness to physical effort differs from its responsiveness to cognitive challenge in older adults.

## Limitations & Conclusion

Our findings must be interpreted within the constraints of the response-signal design, where RTs are measured from response-screen onset rather than stimulus onset. This design constrains the interpretation of $t_0$ to primarily reflect motor execution and response selection, excluding early perceptual/encoding processes (see Limitations section for detailed discussion). Despite these constraints, our results provide clear evidence that effort regulation is critical for older adults because they have a lower "tipping point" where effort becomes interference. The CRUNCH model and CMI framework together explain why the 40% MVC condition pushed older adults past their compensatory capacity, resulting in degraded processing efficiency (reduced drift) and slowed motor execution (increased $t_0$), without the adaptive increase in caution that might have mitigated these effects. These findings underscore the importance of managing effort levels in real-world contexts where older adults must balance physical and cognitive demands.

# Data Availability & Funding

## Sample Size & Precision

With N=67 subjects and \~266 trials per subject (17,834 total), hierarchical estimation provides adequate precision for group-level and subject-level effects. Effective sample sizes (ESS) for all parameters exceeded 400, indicating stable posterior estimates.

## Data & Code Availability

All analysis code and de-identified data are available in the project repository:\
**Repository**: [modeling-pupil-DDM](https://github.com/mohdasti/modeling-pupil-DDM)\
**Analysis scripts**: `R/`, `scripts/`\
**Report source**: `reports/chap3_ddm_results.qmd`

**Note**: The behavioral dataset and detailed task methodology are described in the LC behavioral report manuscript (see References). This DDM analysis uses the same dataset and participants.

## Funding

This research was supported by the National Institutes of Health (Project ID: 11096010). Additional grant details can be found at: https://reporter.nih.gov/search/l8qkCFX0Cki47b9kZOa3Pg/project-details/11096010. The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institutes of Health.

# Limitations & Future Directions

## Model Family Limitations

1.  **Constant-drift Wiener DDM**: The base Wiener DDM assumes constant drift within each trial and no across-trial variability in drift (sv), starting point (sz), or non-decision time (st₀). This can underfit fast tails, especially in VDT-Hard conditions. The constant-drift Wiener DDM underfits fast RT tails, especially in VDT-Hard. Response-signal timing limits identifiability of across-trial variability. Future work could add a small contaminant mixture, across-trial variability (sv, sz), or urgency/collapsing bounds; LBA/race models may better capture fast-tail dynamics in the Easy/VDT regime.

2.  **Non-decision time (t₀) random effects omitted**: In the response-signal design, t₀ primarily reflects motor execution. We modeled t₀ with group-level intercepts and small task/effort effects but omitted subject-level random effects due to identifiability concerns and initialization failures in pilot models. This may underestimate individual differences in motor execution speed.

3.  **Alternative model families**: Linear Ballistic Accumulator (LBA) or race models may provide better fit for fast-tail dynamics, particularly for Easy/VDT. These models allow for more flexible RT distributions and may better accommodate the response-signal design.

## Design-Specific Limitations

4.  **Response-signal RT measurement**: RTs are measured from response-screen onset, not stimulus onset. This constrains the interpretation of t₀ to motor execution and response selection, excluding early perceptual/encoding processes. While this is appropriate for the current design, it limits generalizability to traditional RT paradigms.

5.  **Effort manipulation**: Physical effort (grip force) may interact with motor execution in complex ways not fully captured by small fixed effects on t₀. Future work integrating EMG or kinematic measures could provide richer insights into effort-motor interactions.

## Misfit in Easy/VDT

6.  **Fast-tail misfit**: The most pronounced misfit occurs in Easy/VDT conditions, where the model underpredicts the frequency of very fast correct responses. This suggests a subset of trials may reflect:

    -   Anticipatory responses (partially captured by 2% censoring)
    -   A "fast-guess" process not represented in the base DDM
    -   Extremely high drift rates that are incompatible with the assumed Wiener process for a small subset of trials

    Sensitivity analyses (2% censoring, unconditional PPCs) confirm that substantive conclusions are robust, but future work should explore mixture models or urgency signals to better account for these fast responses.

# Conclusions

This chapter presents a comprehensive hierarchical Wiener DDM analysis of a response-signal change-detection task in older adults. The primary model, in which task difficulty modulates drift rate and boundary separation, with starting-point bias constant across difficulty levels (reflecting the randomized trial design), is strongly supported by LOO cross-validation and shows acceptable fit to subject-wise mid-body RT quantiles. Key findings—difficulty effects on v and a; task-specific differences in bias; and small effort effects—are robust across multiple sensitivity analyses. While the base Wiener DDM shows localized misfit in fast tails (especially Easy/VDT), this does not undermine the core substantive conclusions. Future extensions incorporating across-trial variability, urgency, or mixture models may further improve absolute fit.

# Supplementary Figures

## S1. Conditional Accuracy Function (CAF)

```{r}
#| label: fig-caf
#| fig-cap: "Conditional Accuracy Function (CAF). Empirical accuracy by RT bin for each Task × Effort × Difficulty combination. Shows the speed–accuracy tradeoff: faster responses (lower bins) tend toward chance accuracy, while slower responses show higher accuracy, consistent with evidence accumulation over time."
#| fig-width: 95
#| fig-align: center
knitr::include_graphics(fig_path("fig_caf.pdf"))
```

## S2. PPC Residual Heatmaps

```{r}
#| label: fig-ppc-heatmaps
#| fig-cap: "PPC Residual Heatmaps. KS statistic and QP RMSE by Task × Effort × Difficulty for all models (top panel) and primary model only (bottom panel). Darker red indicates larger residuals (poorer fit). The primary model shows acceptable fit across most cells, with notable misfit in Easy/VDT conditions."
#| fig-width: 100
#| fig-align: center
knitr::include_graphics(fig_path("fig_ppc_heatmaps.pdf"))
```

### Heatmap Detail Tables

```{r}
#| label: tbl-ppc-heatmap-wide
#| tbl-cap: "PPC Residual Heatmap (Wide Format)"
if (!is.null(heatmap_wide)) {
  # Function to clean factor level values
  clean_factor_levels <- function(df) {
    df <- df %>%
      mutate(
        # Clean task values
        task = case_when(
          task == "VDT" ~ "VDT",
          task == "ADT" ~ "ADT",
          TRUE ~ as.character(task)
        ),
        # Clean effort condition values
        effort_condition = case_when(
          effort_condition == "Low_Force_5pct" ~ "Low",
          effort_condition == "High_Force_40pct" ~ "High",
          effort_condition == "Low" ~ "Low",
          effort_condition == "High" ~ "High",
          TRUE ~ as.character(effort_condition)
        ),
        # Clean difficulty level values
        difficulty_level = case_when(
          difficulty_level == "Standard" ~ "Standard",
          difficulty_level == "Easy" ~ "Easy",
          difficulty_level == "Hard" ~ "Hard",
          TRUE ~ as.character(difficulty_level)
        )
      )
    return(df)
  }
  
  heatmap_wide %>%
    clean_factor_levels() %>%
    mutate(across(where(is.numeric), ~round(.x, 3))) %>%
    gt() %>%
    tab_header(title = md("**PPC Residual Heatmap (Wide Format)**")) %>%
    cols_label(
      task = "Task",
      effort_condition = "Effort",
      difficulty_level = "Difficulty",
      ks_mean_max = "KS Statistic",
      qp_rmse_max = "QP RMSE"
    )
}
```

## S3. Unconditional Pooled PPC Metrics (Reference)

This table reports metrics from the strict unconditional pooled test (censored 2%), provided for completeness. As noted in the text, this pooled test is overly sensitive to small deviations in fast tails and is superseded by the subject-wise gate (≤15% flagged) and the joint model cell-wise PPCs (Standard/Easy good, VDT-Hard modest misfit).

@tbl-ppc-gate shows the pooled PPC gate summary.

```{r}
#| label: tbl-ppc-gate
#| tbl-cap: "Pooled PPC Gate Summary (Strict Test)"
if (!is.null(ppc_gate)) {
  ppc_gate %>%
    mutate(across(where(is.numeric), ~round(.x, 3))) %>%
    gt() %>%
    tab_header(title = md("**Pooled PPC Gate Summary (Strict Test)**")) %>%
    cols_label(
      n_cells = "N Cells",
      pct_flagged = "% Flagged",
      max_qp = "Max QP RMSE",
      max_ks = "Max KS"
    )
}
```

## S4. Sensitivity Analysis: Exclusion of Sub-Chance Participants

To verify that the inclusion of 12 participants who performed at or below chance (≤55% accuracy) in some conditions did not bias our main findings, we conducted sensitivity analyses comparing the primary model (N=67) with models fit after excluding these participants (N=55).

**Method**: We refit the primary model (Model3_Difficulty) and an additive model (Model4_Additive) on the reduced dataset excluding sub-chance participants. Parameter estimates were compared using delta (sensitivity - baseline) with conservative 95% credible intervals. If the delta CI includes zero and the baseline and sensitivity CIs overlap, we conclude the parameter is robust to exclusion.

@tbl-sensitivity-subchance shows the sensitivity analysis results.

```{r}
#| label: tbl-sensitivity-subchance
#| tbl-cap: "Sensitivity Analysis: Excluding Sub-Chance Participants"
if (!is.null(sensitivity_summary)) {
  # Function to clean model names (reuse from LOO table)
  clean_model_name <- function(model) {
    model <- as.character(model)
    
    # Single parameter models
    model <- ifelse(model == "v", "Difficulty → v (drift)", model)
    model <- ifelse(model == "z", "Difficulty → z (bias)", model)
    model <- ifelse(model == "a", "Difficulty → a (boundary)", model)
    
    # Two-parameter combinations
    model <- ifelse(model == "v_z", "Difficulty → v + z", model)
    model <- ifelse(model == "v_a", "Difficulty → v + a", model)
    model <- ifelse(model == "z_a", "Difficulty → z + a", model)
    
    # Three-parameter combination
    model <- ifelse(model == "v_z_a", "Difficulty → v + a + z", model)
    model <- ifelse(model == "v_a_z", "Difficulty → v + a + z", model)
    
    # Model number formats
    model <- gsub("Model3_Difficulty", "Difficulty → v (drift)", model)
    model <- gsub("Model4_Additive", "Additive (v + a + z)", model)
    model <- gsub("Model5_Interaction", "Interaction", model)
    model <- gsub("Model10_Param_v_bs", "v + a parameterized", model)
    
    # Remove common prefixes
    model <- gsub("^Difficulty_on_", "", model)
    model <- gsub("^difficulty_", "", model)
    
    # Format underscores as separators
    model <- gsub("_", " ", model)
    
    return(model)
  }
  
  # Function to clean parameter names (reuse from DDM parameter function)
  clean_ddm_parameter <- function(param) {
    param <- as.character(param)
    original <- param
    n <- length(param)
    result <- character(n)
    
    for (i in seq_len(n)) {
      p <- param[i]
      orig <- original[i]
      
      # Determine parameter type from prefix
      param_type <- ""
      if (grepl("^bs_", p)) {
        param_type <- "Boundary (a)"
        p <- gsub("^bs_", "", p)
      } else if (grepl("^bias_", p)) {
        param_type <- "Bias (z)"
        p <- gsub("^bias_", "", p)
      } else if (grepl("^ndt_", p)) {
        param_type <- "Non-decision time (t₀)"
        p <- gsub("^ndt_", "", p)
      } else if (grepl("^b_", p)) {
        param_type <- "Drift (v)"
        p <- gsub("^b_", "", p)
      } else {
        # Try to infer from content
        if (grepl("bs|boundary", orig, ignore.case = TRUE)) {
          param_type <- "Boundary (a)"
        } else if (grepl("ndt|non.decision", orig, ignore.case = TRUE)) {
          param_type <- "Non-decision time (t₀)"
        } else if (grepl("bias", orig, ignore.case = TRUE)) {
          param_type <- "Bias (z)"
        } else {
          param_type <- "Drift (v)"  # Default
        }
      }
      
      # Handle Intercept
      if (p == "Intercept" || orig == "Intercept") {
        result[i] <- paste0(param_type, ": Intercept")
        next
      }
      
      # Handle task-specific parameters that are already formatted (e.g., "Drift (v): ADT")
      # These come from the updated extraction script that computes task-specific intercepts
      if (grepl(": (ADT|VDT)$", orig, ignore.case = TRUE)) {
        result[i] <- orig  # Pass through already-formatted task-specific parameters
        next
      }
      
      # Step 1: Check if this is an interaction (has colon between different factors in raw R format)
      # Interactions have colons between factor patterns like difficulty_level:task or effort_condition:task
      is_raw_interaction <- grepl("_level:", p) || grepl("_condition:", p) || 
                           (grepl("difficulty_level", p) && grepl(":task", p)) ||
                           (grepl("effort_condition", p) && grepl(":task", p)) ||
                           (grepl("difficulty_level", p) && grepl(":effort_condition", p))
      
      if (is_raw_interaction) {
        # Handle interactions: split by colon between factors, clean each part, join with ×
        # Pattern: difficulty_levelHard:taskVDT -> split -> clean -> "Difficulty: Hard × Task: VDT"
        if (grepl(":", p) && !grepl(" × ", p)) {
          # Split by colon (assuming only one colon between factors for interactions)
          parts <- strsplit(p, ":")[[1]]
          # Clean each part
          cleaned_parts <- character(length(parts))
          for (j in seq_along(parts)) {
            part <- parts[j]
            # Clean difficulty
            part <- gsub("difficulty_levelEasy", "Difficulty: Easy", part, ignore.case = TRUE)
            part <- gsub("difficulty_levelHard", "Difficulty: Hard", part, ignore.case = TRUE)
            part <- gsub("difficulty_levelStandard", "Difficulty: Standard", part, ignore.case = TRUE)
            # Clean task
            part <- gsub("^taskVDT$", "Task: VDT", part, ignore.case = TRUE)
            part <- gsub("^taskADT$", "Task: ADT", part, ignore.case = TRUE)
            # Clean effort
            part <- gsub("^effort_conditionLow_Force_5pct$", "Effort: Low", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionLow_MVC$", "Effort: Low", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionLow$", "Effort: Low", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionHigh_Force_40pct$", "Effort: High", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionHigh_MVC$", "Effort: High", part, ignore.case = TRUE)
            part <- gsub("^effort_conditionHigh$", "Effort: High", part, ignore.case = TRUE)
            cleaned_parts[j] <- part
          }
          # Join with ×
          p <- paste(cleaned_parts, collapse = " × ")
        }
      } else {
        # Step 2: Main effects - clean normally (preserve colons)
      # Clean difficulty levels (flexible matching)
      p <- gsub("difficulty_levelEasy", "Difficulty: Easy", p, ignore.case = TRUE)
      p <- gsub("difficulty_levelHard", "Difficulty: Hard", p, ignore.case = TRUE)
      p <- gsub("difficulty_levelStandard", "Difficulty: Standard", p, ignore.case = TRUE)
      
      # Clean task
      p <- gsub("taskVDT", "Task: VDT", p, ignore.case = TRUE)
      p <- gsub("taskADT", "Task: ADT", p, ignore.case = TRUE)
      
      # Clean effort conditions (handle all variations - order matters!)
      p <- gsub("effort_conditionLow_Force_5pct", "Effort: Low", p, ignore.case = TRUE)
      p <- gsub("effort_conditionLow_MVC", "Effort: Low", p, ignore.case = TRUE)
      p <- gsub("effort_conditionLow", "Effort: Low", p, ignore.case = TRUE)
      p <- gsub("effort_conditionHigh_Force_40pct", "Effort: High", p, ignore.case = TRUE)
      p <- gsub("effort_conditionHigh_MVC", "Effort: High", p, ignore.case = TRUE)
      p <- gsub("effort_conditionHigh", "Effort: High", p, ignore.case = TRUE)
      }
      
      # Add parameter type prefix if we have meaningful content
      if (p != orig && param_type != "") {
        # Check if param already starts with a parameter type (avoid duplication)
        if (!grepl("^(Drift|Boundary|Non-decision|Bias)", p)) {
          result[i] <- paste0(param_type, ": ", p)
        } else {
          result[i] <- p
        }
      } else {
        result[i] <- p
      }
    }
    
    return(result)
  }
  
  sens_subchance <- sensitivity_summary %>%
    filter(sensitivity == "exclude_subchance") %>%
    mutate(
      model_clean = clean_model_name(model),
      parameter_clean = clean_ddm_parameter(parameter),
      across(where(is.numeric), ~round(.x, 3))
    ) %>%
    select(model_clean, parameter_clean, baseline_estimate, sensitivity_estimate, delta, 
           delta_ci_lower, delta_ci_upper, ci_overlap, delta_contains_zero) %>%
    rename(model = model_clean, parameter = parameter_clean) %>%
    arrange(model, parameter)
  
  if (nrow(sens_subchance) > 0) {
    sens_subchance %>%
      gt() %>%
      tab_header(title = md("**Sensitivity Analysis: Excluding Sub-Chance Participants**")) %>%
      cols_label(
        model = "Model",
        parameter = "Parameter",
        baseline_estimate = "Baseline",
        sensitivity_estimate = "Excluded",
        delta = "Δ",
        delta_ci_lower = "Δ CI Lower",
        delta_ci_upper = "Δ CI Upper",
        ci_overlap = "CI Overlap",
        delta_contains_zero = "Δ Contains 0"
      ) %>%
      tab_footnote(
        footnote = "Baseline: N=67 (includes sub-chance). Excluded: N=55 (excludes sub-chance). Δ = Excluded - Baseline. If Δ CI contains 0 and CIs overlap, parameter is robust.",
        locations = cells_column_labels(columns = delta_contains_zero)
      )
  } else {
    cat("Sensitivity analysis results for sub-chance exclusion not available.")
  }
} else {
  cat("Sensitivity analysis summary not available.")
}
```

**Results**: Most key parameters showed robust estimates when excluding sub-chance participants. For Model3_Difficulty and Model4_Additive, the drift intercept and boundary separation showed delta CIs that included zero, indicating no meaningful change. The Easy difficulty effect was also robust. The Hard difficulty effect showed a small shift (Δ ≈ -0.10, delta CI did not include zero), but this represents a small change in magnitude (\~6.5% of the baseline estimate) and does not alter the substantive conclusion that Hard trials show negative drift relative to Standard. **Conclusion**: The inclusion of sub-chance participants did not meaningfully alter main effects or substantive conclusions, supporting our decision to retain all 67 participants to maximize sample size and leverage hierarchical modeling's ability to stabilize estimates through shrinkage.

# References {.unnumbered}

::: {#refs}
:::

*Note: The LC behavioral report manuscript (in preparation/published) describes the behavioral dataset and methodology used in this analysis. Full citation details will be added when available.*


